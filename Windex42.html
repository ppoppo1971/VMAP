<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>테스트</title>
    <!-- Kakao Maps JavaScript SDK (지도 렌더링용) -->
    <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=f1268a7e77f3b182e700b92b45d98082&autoload=false&libraries=services"></script>
    
    <script>
      // 파일명에 맞춰 타이틀 자동 설정
      function setTitleFromFilename() {
        const filename = window.location.pathname.split('/').pop().replace('.html', '');
        document.title = filename;
      }
      // 페이지 로드 시 타이틀 설정
      window.addEventListener('load', setTitleFromFilename);
    </script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #map {
            width: 100vw;
            height: 100vh;
            min-height: 100%;
        }
        h1 {
            display: none;
        }
        /* 활성 지도 배지 */
        #activeMapBadge {
            position: absolute;
            top: 10px;
            left: 30px;
            z-index: 15; /* 사이드 패널(z-index:10) 위 */
            background: transparent;
            color: rgba(255, 255, 255, 0.98);
            border-radius: 0;
            padding: 0;
            font-weight: 800;
            font-size: 1.2rem; /* 약 130% */
            box-shadow: none;
            font-family: 'Noto Sans KR', sans-serif;
        }
        /* 사이드바 스타일 */
        #customMapMenu {
            position: absolute;
            top: 40px;
            left: 30px;
            z-index: 10;
            width: 220px;
            background: rgba(255,255,255,0.86);
            border: 1px solid rgba(255,255,255,0.35);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.18);
            padding: 12px 9px 9px 9px;
            display: flex;
            flex-direction: column;
            gap: 9px;
            font-family: 'Noto Sans KR', sans-serif;
            backdrop-filter: blur(6px) saturate(110%);
            -webkit-backdrop-filter: blur(6px) saturate(110%);
            transition: box-shadow 0.2s, left 0.3s, opacity 0.3s, background-color 0.2s;
        }
        #customMapMenu.hide {
            left: -260px;
            opacity: 0;
            pointer-events: none;
        }
        #customMapMenu h2 {
            font-size: 1.2rem;
            font-weight: 700;
            margin: 0 0 12px 0;
            color: #222;
        }
        .menu-group {
            margin-bottom: 5px;
        }
        .menu-group label {
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 6px;
            display: block;
            color: #555;
        }
        /* 공통 버튼 스타일 */
        .menu-group button, .toggle-btn {
            width: 100%;
            background: #f7f7f7;
            border: none;
            border-radius: 8px;
            padding: 5px 0;
            margin-bottom: 3px;
            font-size: 1rem;
            color: #333;
            cursor: pointer;
            transition: background 0.15s, color 0.15s;
        }
        .menu-group button:hover, .toggle-btn:hover {
            background: #e0e7ff;
            color: #1d4ed8;
        }
        .menu-group .submenu {
            margin-left: 12px;
            margin-top: 4px;
        }
        /* 사이드 패널 토글 버튼 */
        #menuToggleBtn {
            position: absolute;
            top: 50px;
            left: 18px;
            z-index: 20;
            background: #1d4ed8;
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.3rem;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
            display: none;
            align-items: center;
            justify-content: center;
        }
        #menuToggleBtn.show {
            display: flex;
        }
        #customMapMenu .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.2rem;
            color: #888;
            cursor: pointer;
        }
        .toggle-btn {
            text-align: left;
            font-weight: 600;
        }
        /* 하위 옵션 들여쓰기 */
        .submenu {
            margin-left: 20px;
        }
        .submenu .submenu {
            margin-left: 20px;
        }
        .submenu button {
            width: 90%;
            margin-left: 0;
        }
        /* 구글맵 하위 옵션 들여쓰기 */
        #googleMapMenu > .toggle-btn {
            margin-left: 20px;
        }
        /* 법정경계 메뉴 스타일 */
        #vworldBoundaryMenu {
            margin-left: 20px;
        }
        #vworldBoundaryMenu button {
            width: 90%;
            margin-left: 0;
        }
        /* 검색 결과 패널 */
        #searchResultsPanel {
            display: none;
            max-height: 320px;
            overflow-y: auto;
            background: #fff;
            border: 1px solid #eee;
            border-radius: 10px;
            padding: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
        }
        .search-results-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
            font-weight: 700;
            color: #222;
        }
        .search-results-close {
            background: none;
            border: none;
            font-size: 1rem;
            color: #888;
            cursor: pointer;
        }
        .search-result-item {
            padding: 8px;
            border-radius: 8px;
            background: #f9fafb;
            margin-bottom: 6px;
            cursor: pointer;
            transition: background 0.15s, color 0.15s;
        }
        .search-result-item:hover {
            background: #e0e7ff;
            color: #1d4ed8;
        }
        .result-title {
            font-weight: 600;
            margin: 0 0 2px 0;
            font-size: 0.95rem;
        }
        .result-sub {
            margin: 0;
            font-size: 0.85rem;
            color: #555;
        }
        /* 50:50 로드뷰 분할 레이아웃 */
        #rvWrapper { position: absolute; top: 0; right: 0; width: 50vw; height: 100vh; z-index: 6; display: none; background: #fff; }
        body.rv-active #rvWrapper { display: block; }
        #roadview { width: 100%; height: 100%; }
        #rvWrapper .rv-close { position: absolute; top: 8px; right: 10px; z-index: 7; background: rgba(0,0,0,0.6); color: #fff; border: none; border-radius: 6px; padding: 4px 8px; cursor: pointer; font-size: 0.9rem; }
        
        /* 구글맵 정보창 X 버튼 숨기기 */
        .gm-ui-hover-effect[title="닫기"] {
            display: none !important;
        }
        .gm-style-iw-d + button {
            display: none !important;
        }
        
        /* 카카오맵 커스텀 정보창 스타일 (구글맵과 동일한 모양) */
        .custom-info-window {
            background: white;
            border-radius: 8px;
            padding: 10px;
            min-width: 200px;
            box-shadow: 0 2px 7px 1px rgba(0, 0, 0, 0.3);
            position: relative;
            font-family: Roboto, Arial, sans-serif;
            font-size: 13px;
            z-index: 10;
        }
        
        /* 브이월드 지적도 WMS 이미지에 빨간색 필터 적용 */
        img[src*="api.vworld.kr"][src*="lp_pa_cbnd"] {
            filter: contrast(1.2) brightness(1.1) hue-rotate(240deg) saturate(2) !important;
            mix-blend-mode: multiply !important;
        }
        
        /* 구글맵 GroundOverlay 지적도 이미지 */
        img[src*="api.vworld.kr/req/wms"][src*="LAYERS=lp_pa_cbnd"] {
            filter: contrast(1.2) brightness(1.1) hue-rotate(240deg) saturate(2) !important;
            mix-blend-mode: multiply !important;
        }
        
        /* 지적도 관련 모든 이미지에 적용 */
        .gm-style img[src*="lp_pa_cbnd"] {
            filter: contrast(1.2) brightness(1.1) hue-rotate(240deg) saturate(2) !important;
            mix-blend-mode: multiply !important;
        }
        
        /* 지적도근점(dt_d007) WMS를 짙은 마젠타 계열로 보정 (텍스트 포함) */
        img[src*="api.vworld.kr"][src*="dt_d007"],
        .gm-style img[src*="dt_d007"] {
            /* 검정/회색 라벨까지 재착색될 수 있도록 전체 이미지를 컬러라이즈 */
            filter: invert(14%) sepia(98%) saturate(7479%) hue-rotate(293deg) brightness(82%) contrast(111%) !important;
        }
        
        .custom-info-window::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-top: 12px solid white;
            filter: drop-shadow(0 2px 1px rgba(0, 0, 0, 0.2));
        }
    </style>
</head>
<body>
    <h1>테스트</h1>
    <!-- 지도를 표시할 div 요소 -->
    <div id="map"></div>
    <!-- 현재 활성 지도 표시 배지 -->
    <div id="activeMapBadge" aria-live="polite">구글맵 - 일반</div>
    <!-- 사이드 패널 토글 버튼 (패널이 숨겨졌을 때만 보임) -->
    <button id="menuToggleBtn" class="show" onclick="showMenu()" title="메뉴 열기">☰</button>
    <!-- 왼쪽 고정형 사이드바 메뉴 -->
    <div id="customMapMenu" class="hide">
      <button class="close-btn" onclick="hideMenu()" title="닫기">×</button>
      <h2>지도 유형 선택</h2>
      <div class="menu-group">
        <input type="text" id="addressInput" placeholder="장소/주소를 입력하세요" style="width: 98%; margin-bottom: 6px;" onkeydown="if(event.key==='Enter'){searchAddress();}">
        <div id="searchResultsPanel">
          <div class="search-results-header">
            <span>검색 결과</span>
            <button class="search-results-close" onclick="hideSearchResults()">닫기</button>
          </div>
          <div id="searchResultsList"></div>
        </div>
      </div>
      <div class="menu-group">
        <button id="googleMapToggleBtn" class="toggle-btn" onclick="toggleGoogleMapMenu()">+구글맵</button>
        <div id="googleMapMenu" style="display:none; margin-top:8px; margin-left:20px;">
          <button id="roadmapToggleBtn" class="toggle-btn" style="margin-left:0;" onclick="toggleRoadmapMenuAndSetRoadmap()">+일반</button>
          <div id="roadmapMenu" class="submenu" style="display:none;">
            <button onclick="setMapType('terrain')">지형</button>
          </div>
          <button id="satelliteToggleBtn" class="toggle-btn" style="margin-left:0;" onclick="toggleSatelliteMenuAndSetSatellite()">+위성</button>
          <div id="satelliteMenu" class="submenu" style="display:none;">
            <button onclick="setMapType('hybrid')">하이브리드</button>
          </div>
        </div>
      </div>
      <div class="menu-group">
        <button id="vworldToggleBtn" class="toggle-btn" onclick="toggleVworldMenu()">+브이월드</button>
        <div id="vworldMenu" class="submenu" style="display:none;">
          <button onclick="setMapType('브이월드일반')">일반</button>
          <button onclick="setMapType('브이월드영상')">영상</button>
        </div>
      </div>
      <div class="menu-group">
        <button id="kakaoMapToggleBtn" class="toggle-btn" onclick="toggleKakaoMapMenu()">+카카오맵</button>
      <div id="kakaoMapMenu" style="display:none; margin-top:8px; margin-left:20px;">
          <button onclick="loadKakaoMap('normal')">일반</button>
          <button onclick="loadKakaoMap('skyview')">스카이뷰</button>
          <button onclick="toggleRoadview()">로드뷰</button>
        </div>
      </div>
      <div class="menu-group">
        <button id="vworldBoundaryToggleBtn" class="toggle-btn" onclick="toggleVworldBoundaryMenu()">+법정경계</button>
        <div id="vworldBoundaryMenu" class="submenu" style="display:none;">
          <button onclick="loadVworldBoundary('lt_c_adsigg')">시군구</button>
          <button onclick="loadVworldBoundary('lt_c_ademd')">읍면동</button>
          <button onclick="loadVworldBoundary('lt_c_adri')">리</button>
          <button onclick="clearVworldBoundary()">경계제거</button>
        </div>
      </div>
      <div class="menu-group">
        <button id="cadastralToggleBtn" class="toggle-btn" onclick="toggleCadastralOverlay()">연속지적도</button>
        <button id="controlPointToggleBtn" class="toggle-btn" onclick="toggleControlPointOverlay()">지적도근점</button>
      </div>
    </div>
    <div id="kakaoMapContainer" style="display:none; width:100vw; height:100vh; position:absolute; top:0; left:0; z-index:5;">
      <div id="kakaoMapDiv" style="width:100%; height:100%;"></div>
    </div>
    <!-- 50:50 우측 로드뷰 패널 -->
    <div id="rvWrapper">
      <button class="rv-close" onclick="closeRoadviewAll()" title="로드뷰 닫기">×</button>
      <div id="roadview"></div>
    </div>
    <script>
      // 전역 변수들
      let map, kakaoMap, kakaoRoadview, kakaoRoadviewClient;
      let vworldBoundaryOverlay = null, currentBoundaryLayer = null, cadastralOverlay = null;
      let controlPointOverlay = null; // 지적도근점(구글)
      let addressMarkers = [], kakaoMarkers = [], lastSearchResults = [];
      let lastSearchMode = 'keyword';
      let kakaoCadastralOverlayEl = null, cadastralOverlayMode = null;
      let kakaoControlPointOverlayEl = null, controlPointOverlayMode = null; // 지적도근점(카카오)
      // WFS 벡터 렌더링 상태(구글/카카오)
      let googleCadastralDataLayer = null;
      let googleControlPointOverlays = [];
      let kakaoCadastralPolygons = [];
      let kakaoControlPointOverlays = [];
      let cadastralUpdateTimer = null, boundaryUpdateTimer = null;
      let isRoadviewClickMode = false, roadviewOverlayOn = false, roadviewMarker = null;
      let addressInfoWindow = null, addressInfoMarker = null;
      let googleAddressInfoWindow = null, googleAddressInfoMarker = null;
      
      // DOM 캐시
      let cachedElements = {};
      function getElement(id) {
        if (!cachedElements[id]) {
          cachedElements[id] = document.getElementById(id);
        }
        return cachedElements[id];
      }
      
      // API 설정 상수
      const CONFIG = {
        VWORLD_API_KEY: '46F4304E-84DC-3F56-92F1-6A98A0370A31',
        KAKAO_API_KEY: 'KakaoAK c27024d37ac99abf233b12f0efa39099',
        VWORLD_API_URL: 'https://api.vworld.kr/req/wms',
        VWORLD_CONTROL_POINT_WMS_URL: 'https://api.vworld.kr/ned/wms/LgstspSpceService',
        VWORLD_CADASTRAL_WFS_URL: 'https://api.vworld.kr/ned/wfs/getCtnlgsSpceWFS',
        VWORLD_CONTROL_POINT_WFS_URL: 'https://api.vworld.kr/ned/wfs/getLgstspSpceWFS',
        KAKAO_LOCAL_API_URL: 'https://dapi.kakao.com/v2/local',
        MAX_BOUNDARY_ZOOM: 32,
        MAX_CADASTRAL_ZOOM: 32,
        DEBOUNCE_DELAY: 1000
      };
      // 디바운스 헬퍼 함수
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
      
      // API URL 빌더 함수
      function buildApiUrl(baseUrl, params) {
        const urlParams = new URLSearchParams();
        Object.entries(params).forEach(([key, value]) => {
          urlParams.set(key, value);
        });
        return `${baseUrl}?${urlParams.toString()}`;
      }
      
      // VWorld WMS 파라미터 생성
      function createVworldWmsParams(layerType, bbox, width, height) {
        return {
          key: CONFIG.VWORLD_API_KEY,
          service: 'WMS',
          request: 'GetMap',
          version: '1.3.0',
          layers: layerType,
          styles: '',
          crs: 'EPSG:4326',
          bbox: bbox,
          width: width,
          height: height,
          format: 'image/png',
          transparent: 'true',
          exceptions: 'text/xml'
        };
      }
      
      // 지적도 파라미터 생성
      function createCadastralParams(bbox, width, height) {
        return {
          KEY: CONFIG.VWORLD_API_KEY,
          SERVICE: 'WMS',
          REQUEST: 'GetMap',
          VERSION: '1.3.0',
          LAYERS: 'lp_pa_cbnd_bonbun,lp_pa_cbnd_bubun',
          STYLES: '',
          CRS: 'EPSG:4326',
          BBOX: bbox,
          WIDTH: width,
          HEIGHT: height,
          FORMAT: 'image/png',
          TRANSPARENT: 'true',
          BGCOLOR: '0xFFFFFF',
          DPI: '96',
          EXCEPTIONS: 'text/xml'
        };
      }
      
      // 활성 지도 배지 갱신
      function setActiveMapBadge(text) {
        const el = getElement('activeMapBadge');
        if (el && el.textContent !== text) el.textContent = text;
      }
      function updateActiveMapLabel() {
        try {
          if (isKakaoVisible() && kakaoMap) {
            const mt = kakaoMap.getMapTypeId && kakaoMap.getMapTypeId();
            const label = (mt === kakao.maps.MapTypeId.SKYVIEW) ? '카카오맵 - 스카이뷰' : '카카오맵 - 일반';
            setActiveMapBadge(label);
            return;
          }
          
          if (map && map.getMapTypeId) {
            const t = map.getMapTypeId();
            let label = '구글맵 - 일반';
            switch (t) {
              case 'roadmap': label = '구글맵 - 일반'; break;
              case 'terrain': label = '구글맵 - 지형'; break;
              case 'satellite': label = '구글맵 - 위성'; break;
              case 'hybrid': label = '구글맵 - 하이브리드'; break;
              case '브이월드일반': label = '브이월드 - 일반'; break;
              case '브이월드영상': label = '브이월드 - 영상'; break;
            }
            setActiveMapBadge(label);
          }
        } catch (e) { 
          // 활성 지도 라벨 업데이트 오류 무시
        }
      }
      // 구글 줌 <-> 카카오 레벨 변환 유틸리티
      function getGoogleZoom() {
        try {
          if (map && map.getZoom) {
            return map.getZoom();
          }
          return null;
        } catch (e) {
          // 구글맵 줌 레벨 가져오기 오류 무시
          return null;
        }
      }
      function googleZoomToKakaoLevel(googleZoom) {
        if (googleZoom == null) return 5;
        const level = 21 - googleZoom; // 대략적 대응식
        return Math.min(14, Math.max(1, level));
      }
      function kakaoLevelToGoogleZoom(kakaoLevel) {
        if (kakaoLevel == null) return 12;
        const zoom = 21 - kakaoLevel;
        return Math.min(21, Math.max(3, zoom));
      }
      // 구글 맵 초기화 함수
      function initMap() {
        // 서울 시청의 위도, 경도 좌표를 중심으로 설정
        var center = { lat: 37.5665, lng: 126.9780 }; // 서울 시청 좌표
        // 구글 맵 객체 생성 및 옵션 설정
        map = new google.maps.Map(document.getElementById('map'), {
          zoom: 12, // 초기 확대 레벨
          center: center, // 지도 중심 좌표
          mapTypeControl: false, // 기본 가로 지도 타입 메뉴 비활성화
          mapTypeControlOptions: {
            // 지도 타입 선택 컨트롤에 표시할 지도 타입 목록
            mapTypeIds: ['roadmap', 'terrain', 'satellite', 'hybrid', '브이월드일반', '브이월드영상'],
            style: google.maps.MapTypeControlStyle.VERTICAL_BAR, // 세로 메뉴
            position: google.maps.ControlPosition.LEFT_TOP // 원하는 위치
          }
        });
        // REST 방식 사용이므로 별도 초기화 불필요

        // 브이월드 일반 지도(기본 지도) 타일 레이어 정의
        var cadastralMapType = new google.maps.ImageMapType({
          // 각 타일의 URL을 반환하는 함수
          getTileUrl: function(coord, zoom) {
            // 브이월드 일반 지도 타일 서버 URL
            return 'https://xdworld.vworld.kr/2d/Base/service/' + zoom + '/' + coord.x + '/' + coord.y + '.png';
          },
          tileSize: new google.maps.Size(256, 256), // 타일 크기 지정
          name: '브이월드일반', // 지도 타입 이름
          maxZoom: 19 // 최대 확대 레벨
        });

        // 브이월드 영상 지도(위성 지도) 타일 레이어 정의
        var vworldSatelliteMapType = new google.maps.ImageMapType({
          // 각 타일의 URL을 반환하는 함수
          getTileUrl: function(coord, zoom) {
            // 브이월드 영상 지도 타일 서버 URL
            return 'https://xdworld.vworld.kr/2d/Satellite/service/' + zoom + '/' + coord.x + '/' + coord.y + '.jpeg';
          },
          tileSize: new google.maps.Size(256, 256), // 타일 크기 지정
          name: '브이월드영상', // 지도 타입 이름
          maxZoom: 19 // 최대 확대 레벨
        });

        // 사용자 정의 지도 타입(브이월드 일반, 브이월드 영상)을 구글 맵에 추가
        map.mapTypes.set('브이월드일반', cadastralMapType);
        map.mapTypes.set('브이월드영상', vworldSatelliteMapType);
        // 기본 지도 타입을 'roadmap'으로 설정
        map.setMapTypeId('roadmap');
        
        // 디바운스된 업데이트 함수들
        const debouncedBoundaryUpdate = debounce(() => {
          if (currentBoundaryLayer && vworldBoundaryOverlay) updateBoundaryOverlay();
        }, CONFIG.DEBOUNCE_DELAY);
        
        const debouncedCadastralUpdate = debounce(() => {
          if (cadastralOverlay) updateCadastralOverlay();
        }, CONFIG.DEBOUNCE_DELAY);
        const debouncedControlPointUpdate = debounce(() => {
          if (controlPointOverlay) updateControlPointOverlay();
        }, CONFIG.DEBOUNCE_DELAY);
        
        // 지도 이동 이벤트 리스너 추가
        map.addListener('bounds_changed', function() {
          debouncedBoundaryUpdate();
          debouncedCadastralUpdate();
          debouncedControlPointUpdate();
        });
        // 초기 활성 지도 배지 갱신
        updateActiveMapLabel();
        // 구글맵 우클릭 주소 정보창 리스너 부착
        attachGoogleMapRightClick();
      }
      function setMapType(type) {
        // 카카오맵이 활성화된 상태라면 구글맵으로 전환
        const wasKakaoVisible = isKakaoVisible();
        if (wasKakaoVisible) {
          showGoogleMap();
        }
        // 지도 타입 설정
        if (map && map.setMapTypeId) {
          map.setMapTypeId(type);
        }
        updateActiveMapLabel();
        
        // 카카오에서 구글로 전환 시 지적도 상태 확인 및 로드
        if (wasKakaoVisible && (cadastralOverlayMode === 'kakao' || kakaoCadastralOverlayEl)) {
          setTimeout(() => {
            loadCadastralOverlay();
          }, 300);
        }
      }
      // 최적화된 메뉴 토글 함수
      function toggleMenu(menuId, btnId, menuName, subMenus = []) {
        const menu = getElement(menuId);
        const btn = getElement(btnId);
        const isHidden = menu.style.display === 'none';
        
        menu.style.display = isHidden ? 'block' : 'none';
        btn.textContent = isHidden ? `-${menuName}` : `+${menuName}`;
        
        if (!isHidden && subMenus.length) {
          subMenus.forEach(({menuId, btnId, btnText}) => {
            getElement(menuId).style.display = 'none';
            getElement(btnId).textContent = btnText;
          });
        }
      }
      
      // 구글맵 메뉴 토글
      function toggleGoogleMapMenu() {
        toggleMenu('googleMapMenu', 'googleMapToggleBtn', '구글맵', [
          {menuId: 'roadmapMenu', btnId: 'roadmapToggleBtn', btnText: '+일반'},
          {menuId: 'satelliteMenu', btnId: 'satelliteToggleBtn', btnText: '+위성'}
        ]);
      }
      // +일반 클릭 시 바로 일반지도를 로드하고, 하위에 지형만 보이도록
      function toggleRoadmapMenuAndSetRoadmap() {
        const menu = document.getElementById('roadmapMenu');
        const btn = document.getElementById('roadmapToggleBtn');
        if(menu.style.display === 'none') {
          setMapType('roadmap');
          menu.style.display = 'block';
          btn.textContent = '-일반';
        } else {
          menu.style.display = 'none';
          btn.textContent = '+일반';
        }
      }
      // +위성 클릭 시 바로 위성지도를 로드하고, 하위에 하이브리드만 보이도록
      function toggleSatelliteMenuAndSetSatellite() {
        const menu = document.getElementById('satelliteMenu');
        const btn = document.getElementById('satelliteToggleBtn');
        if(menu.style.display === 'none') {
          setMapType('satellite');
          menu.style.display = 'block';
          btn.textContent = '-위성';
        } else {
          menu.style.display = 'none';
          btn.textContent = '+위성';
        }
      }
      // 브이월드 메뉴 토글
      function toggleVworldMenu() {
        toggleMenu('vworldMenu', 'vworldToggleBtn', '브이월드');
      }
      
      // 카카오맵 메뉴 토글
      function toggleKakaoMapMenu() {
        toggleMenu('kakaoMapMenu', 'kakaoMapToggleBtn', '카카오맵');
      }
      function loadKakaoMap(type) {
        const container = document.getElementById('kakaoMapContainer');
        const googleDiv = document.getElementById('map');
        
        if (!container || !googleDiv) {
          console.log('카카오맵 컨테이너 또는 구글맵 div를 찾을 수 없습니다.');
          return;
        }
        
        const wasVisible = container.style.display !== 'none';
        
        // 컨테이너 전환
        googleDiv.style.display = 'none';
        container.style.display = 'block';
        
        // Kakao SDK 비동기 로드 후 지도 생성/업데이트
        if (window.kakao && kakao.maps && kakao.maps.load) {
          kakao.maps.load(function() {
            try {
              // 처음 카카오로 전환되는 순간에만 구글 중심/배율을 강제 동기화
              createOrUpdateKakaoMap(type, !wasVisible);
              updateActiveMapLabel();
              ensureRoadviewInitialized();
              attachOrDetachRoadviewClick();
            } catch (e) {
              console.log('카카오맵 생성/업데이트 오류:', e);
            }
          });
        } else {
          console.log('카카오맵 SDK가 로드되지 않았습니다.');
        }
      }
      function showGoogleMap() {
        const kakaoContainer = document.getElementById('kakaoMapContainer');
        const googleDiv = document.getElementById('map');
        
        if (!googleDiv) return;
        
        // 카카오에서 구글로 전환 시 중심/배율 동기화
        if (kakaoMap && kakaoContainer && kakaoContainer.style.display !== 'none') {
          try {
            const kc = kakaoMap.getCenter();
            const kl = kakaoMap.getLevel();
            const gZoom = kakaoLevelToGoogleZoom(kl);
            if (map && map.setCenter && map.setZoom) {
              map.setCenter({ lat: kc.getLat(), lng: kc.getLng() });
              map.setZoom(gZoom);
            }
                  } catch (e) { 
          // 카카오맵에서 구글맵으로 전환 시 동기화 오류 무시
        }
        }
        
        // 컨테이너 전환
        if (kakaoContainer) kakaoContainer.style.display = 'none';
        googleDiv.style.display = 'block';
        
        // 카카오맵 전환 시 정보창 제거
        clearAddressInfoWindow();
        
        // 활성 지도 배지 업데이트
        updateActiveMapLabel();
        
        // 구글로 전환 시 로드뷰 감춤
        hideRoadview();
        
        // 카카오맵에서 지적도가 활성화되어 있었다면 구글맵에도 로드
        if (cadastralOverlayMode === 'kakao' || kakaoCadastralOverlayEl) {
          setTimeout(() => {
            loadCadastralOverlay();
          }, 500);
        }

        // 카카오맵에서 지적도근점이 활성 상태였다면 구글맵에도 로드
        if (controlPointOverlayMode === 'kakao' || kakaoControlPointOverlayEl) {
          setTimeout(() => {
            loadControlPointOverlay();
          }, 600);
        }
      }
      function isKakaoVisible() {
        const container = document.getElementById('kakaoMapContainer');
        return container && container.style.display !== 'none';
      }
      function createOrUpdateKakaoMap(type, syncFromGoogle) {
        try {
          const mapTypeId = (type === 'skyview') ? kakao.maps.MapTypeId.SKYVIEW : kakao.maps.MapTypeId.ROADMAP;
          const centerFromGoogle = getCurrentCenter();
          const gZoom = getGoogleZoom();
          const levelFromGoogle = googleZoomToKakaoLevel(gZoom);
          
          if (!kakaoMap) {
            const container = document.getElementById('kakaoMapDiv');
            if (!container) {
              console.log('카카오맵 div를 찾을 수 없습니다.');
              return;
            }
            
            kakaoMap = new kakao.maps.Map(container, {
              center: new kakao.maps.LatLng(centerFromGoogle.lat, centerFromGoogle.lng),
              level: levelFromGoogle,
              mapTypeId: mapTypeId
            });
            
            attachOrDetachRoadviewClick();
            // 우클릭 이벤트 리스너 추가
            attachKakaoMapRightClick();
          } else {
            if (kakaoMap.setMapTypeId) {
              kakaoMap.setMapTypeId(mapTypeId);
            }
            
            if (syncFromGoogle && kakaoMap.setCenter && kakaoMap.setLevel) {
              kakaoMap.setCenter(new kakao.maps.LatLng(centerFromGoogle.lat, centerFromGoogle.lng));
              kakaoMap.setLevel(levelFromGoogle);
            }
          }
          
          // 컨테이너 표시 직후 리레이아웃
          setTimeout(() => { 
            if (kakaoMap && kakaoMap.relayout) {
              kakaoMap.relayout(); 
            }
          }, 0);
          
          // 지적도가 활성 상태였다면 카카오에도 표시
          if (cadastralOverlay || cadastralOverlayMode === 'google' || 
              (cadastralOverlayMode === null && cadastralOverlay)) {
            loadCadastralOverlayKakao();
          }

          // 지적도근점이 활성 상태였다면 카카오에도 표시
          if (controlPointOverlay || controlPointOverlayMode === 'google' ||
              (controlPointOverlayMode === null && controlPointOverlay)) {
            loadControlPointOverlayKakao();
          }
          
          // 구글에서 존재하는 마커를 카카오로 동기화
          syncMarkersToKakao();
          updateActiveMapLabel();
          
        } catch (e) {
          console.log('카카오맵 생성/업데이트 중 오류:', e);
        }
      }

      // 로드뷰 초기화/토글/갱신
      function ensureRoadviewInitialized() {
        const rvContainer = document.getElementById('roadview');
        if (!rvContainer) return;
        if (!kakaoRoadviewClient) kakaoRoadviewClient = new kakao.maps.RoadviewClient();
        if (!kakaoRoadview) {
          kakaoRoadview = new kakao.maps.Roadview(rvContainer);
          // 로드뷰 위치 변화 시 지도/마커 동기화
          kakao.maps.event.addListener(kakaoRoadview, 'position_changed', function() {
            try {
              const pos = kakaoRoadview.getPosition();
              if (pos && kakaoMap) {
                updateRoadviewMarkerPosition(pos);
              }
            } catch (e) { /* ignore */ }
          });
        }
      }
      function showRoadviewAtLatLng(lat, lng) {
        ensureRoadviewInitialized();
        if (!kakaoRoadviewClient || !kakaoRoadview) return;
        const position = new kakao.maps.LatLng(lat, lng);
        kakaoRoadviewClient.getNearestPanoId(position, 50, function(panoId) {
          if (!!panoId) {
            document.body.classList.add('rv-active');
            kakaoRoadview.setPanoId(panoId, position);
            updateRoadviewMarkerPosition(position);
          } else {
            alert('해당 위치 주변에 로드뷰가 없습니다.');
          }
        });
      }
      function toggleRoadview() {
        if (!isKakaoVisible()) { alert('카카오맵을 먼저 활성화하세요.'); return; }
        if (!isRoadviewClickMode) { openRoadview(); } else { closeRoadviewAll(); }
      }
      function openRoadview() {
        isRoadviewClickMode = true;
        document.body.classList.add('rv-active');
        toggleRoadviewOverlay(true);
        attachOrDetachRoadviewClick();
      }
      function closeRoadviewAll() {
        isRoadviewClickMode = false;
        document.body.classList.remove('rv-active');
        toggleRoadviewOverlay(false);
        attachOrDetachRoadviewClick();
      }
      
      function hideRoadview() {
        document.body.classList.remove('rv-active');
      }
      function attachOrDetachRoadviewClick() {
        if (!kakaoMap) return;
        // 기존 핸들러 제거 후 필요 시 부착
        kakao.maps.event.removeListener(kakaoMap, 'click', onKakaoMapClickForRoadview);
        kakao.maps.event.removeListener(kakaoMap, 'click', onKakaoMapClickForAddressInfo);
        
        if (isKakaoVisible() && isRoadviewClickMode) {
          kakao.maps.event.addListener(kakaoMap, 'click', onKakaoMapClickForRoadview);
        } else {
          // 로드뷰 모드가 아닐 때만 주소 정보창 닫기 이벤트 추가
          kakao.maps.event.addListener(kakaoMap, 'click', onKakaoMapClickForAddressInfo);
        }
      }
      
      // 카카오맵 우클릭 이벤트 리스너 부착
      function attachKakaoMapRightClick() {
        if (!kakaoMap) return;
        kakao.maps.event.addListener(kakaoMap, 'rightclick', onKakaoMapRightClick);
      }
      // 구글맵 우클릭 이벤트 리스너 부착
      function attachGoogleMapRightClick() {
        if (!map || !map.addListener) return;
        map.addListener('rightclick', onGoogleMapRightClick);
        // 일반 클릭 시 정보창 닫기
        map.addListener('click', function() {
          clearAddressInfoWindow();
        });
      }
      
      // 카카오맵 클릭 핸들러 (주소 정보창 닫기용)
      function onKakaoMapClickForAddressInfo() {
        clearAddressInfoWindow();
      }
      
      // 카카오맵 우클릭 이벤트 핸들러
      function onKakaoMapRightClick(mouseEvent) {
        const latlng = mouseEvent.latLng;
        if (!latlng) return;
        
        // 기존 정보창과 마커 제거
        clearAddressInfoWindow();
        
        // 클릭한 위치에 마커 표시
        addressInfoMarker = new kakao.maps.Marker({
          position: latlng,
          map: kakaoMap
        });
        
        // 주소 검색
        searchAddressFromCoordinates(latlng.getLat(), latlng.getLng());
      }
      // 구글맵 우클릭 이벤트 핸들러
      function onGoogleMapRightClick(mouseEvent) {
        const latlng = mouseEvent && mouseEvent.latLng;
        if (!latlng) return;
        // 기존 정보창과 마커 제거
        clearAddressInfoWindow();
        // 클릭한 위치에 마커 표시
        googleAddressInfoMarker = new google.maps.Marker({
          position: latlng,
          map: map
        });
        // 주소 검색
        const lat = typeof latlng.lat === 'function' ? latlng.lat() : latlng.lat;
        const lng = typeof latlng.lng === 'function' ? latlng.lng() : latlng.lng;
        searchAddressFromCoordinates(lat, lng);
      }
      
      // 한국 좌표계 변환 함수들
      function determineKoreanCoordinateZone(longitude) {
        // 경도에 따른 원점 자동 판별 (국토지리정보원 표준 2002년 이후)
        if (longitude < 126) {
          return { 
            zone: '서부원점', 
            centralMeridian: 125, 
            epsg: 5185, 
            name: 'Korea 2000 / West Belt',
            y0: 600000 // falseY: 60000
          };
        } else if (longitude < 128) {
          return { 
            zone: '중부원점', 
            centralMeridian: 127, 
            epsg: 5186, 
            name: 'Korea 2000 / Central Belt',
            y0: 600000 // falseY: 60000
          };
        } else if (longitude < 130) {
          return { 
            zone: '동부원점', 
            centralMeridian: 129, 
            epsg: 5187, 
            name: 'Korea 2000 / East Belt',
            y0: 600000 // falseY: 60000
          };
        } else {
          return { 
            zone: '동해원점', 
            centralMeridian: 131, 
            epsg: 5188, 
            name: 'Korea 2000 / East Sea Belt',
            y0: 600000 // falseY: 60000
          };
        }
      }
      
      function convertWGS84ToKoreanTM(latitude, longitude) {
        // WGS84 경위도를 한국 TM 좌표계로 변환 (정확한 공식)
        const zoneInfo = determineKoreanCoordinateZone(longitude);
        
        // GRS80 타원체 상수
        const a = 6378137.0; // 장반경 (m)
        const f = 1 / 298.257222101; // 편평률
        const e2 = 2 * f - f * f; // 제1이심률의 제곱
        
        // TM 투영 상수
        const k0 = 1.0; // 축척계수
        const x0 = 200000; // falseEasting (m)
        const y0 = zoneInfo.y0; // falseNorthing (m)
        const lat0 = 38.0; // 원점 위도 (도)
        
        // 라디안 변환
        const phi = latitude * Math.PI / 180; // 위도 (라디안)
        const lambda = longitude * Math.PI / 180; // 경도 (라디안)
        const lambda0 = zoneInfo.centralMeridian * Math.PI / 180; // 중앙경선 (라디안)
        const phi0 = lat0 * Math.PI / 180; // 원점 위도 (라디안)
        
        // 경도차
        const deltaLambda = lambda - lambda0;
        
        // 보조 함수들
        const sin_phi = Math.sin(phi);
        const cos_phi = Math.cos(phi);
        const tan_phi = Math.tan(phi);
        
        const sin2_phi = sin_phi * sin_phi;
        const cos2_phi = cos_phi * cos_phi;
        const tan2_phi = tan_phi * tan_phi;
        
        // 곡률반경
        const nu = a / Math.sqrt(1 - e2 * sin2_phi); // 주곡률반경
        const rho = a * (1 - e2) / Math.pow(1 - e2 * sin2_phi, 1.5); // 자오선곡률반경
        
        // 보조 변수
        const eta2 = (e2 * cos2_phi) / (1 - e2);
        
        // 자오선호장 계산 (M)
        const A0 = a * (1 - e2/4 - 3*e2*e2/64 - 5*e2*e2*e2/256);
        const A2 = a * (3*e2/8 + 3*e2*e2/32 + 45*e2*e2*e2/1024);
        const A4 = a * (15*e2*e2/256 + 45*e2*e2*e2/1024);
        const A6 = a * (35*e2*e2*e2/3072);
        
        const M = A0 * phi - A2 * Math.sin(2*phi) + A4 * Math.sin(4*phi) - A6 * Math.sin(6*phi);
        const M0 = A0 * phi0 - A2 * Math.sin(2*phi0) + A4 * Math.sin(4*phi0) - A6 * Math.sin(6*phi0);
        
        // TM 투영 계산
        const T1 = (M - M0) * k0;
        const T2 = nu * sin_phi * cos_phi * k0 / 2;
        const T3 = nu * sin_phi * cos2_phi * cos_phi * k0 * (5 - tan2_phi + 9*eta2 + 4*eta2*eta2) / 24;
        const T4 = nu * sin_phi * cos2_phi * cos2_phi * cos_phi * k0 * 
                   (61 - 58*tan2_phi + tan2_phi*tan2_phi + 600*eta2 - 330*eta2*tan2_phi) / 720;
        
        const T5 = nu * cos_phi * k0;
        const T6 = nu * cos2_phi * cos_phi * k0 * (1 - tan2_phi + eta2) / 6;
        const T7 = nu * cos2_phi * cos2_phi * cos_phi * k0 * 
                   (5 - 18*tan2_phi + tan2_phi*tan2_phi + 72*eta2 - 58*eta2*tan2_phi) / 120;
        
        // 최종 좌표 계산
        const x = x0 + T5 * deltaLambda + T6 * Math.pow(deltaLambda, 3) + T7 * Math.pow(deltaLambda, 5);
        const y = y0 + T1 + T2 * deltaLambda * deltaLambda + T3 * Math.pow(deltaLambda, 4) + T4 * Math.pow(deltaLambda, 6);
        
        return {
          x: Math.round(x * 1000) / 1000, // 소수점 셋째자리까지
          y: Math.round(y * 1000) / 1000,
          zone: zoneInfo.zone,
          epsg: zoneInfo.epsg,
          centralMeridian: zoneInfo.centralMeridian
        };
      }
      
      // 테스트용 좌표 변환 검증 함수
      function testCoordinateConversion() {
        const testLat = 37.617300;
        const testLng = 126.719286;
        const expectedX = 175216.503;
        const expectedY = 557560.991;
        
        const result = convertWGS84ToKoreanTM(testLat, testLng);
        console.log('테스트 결과:');
        console.log(`입력: 위도 ${testLat}, 경도 ${testLng}`);
        console.log(`출력: X ${result.x}, Y ${result.y}`);
        console.log(`예상: X ${expectedX}, Y ${expectedY}`);
        console.log(`차이: X ${Math.abs(result.x - expectedX).toFixed(3)}, Y ${Math.abs(result.y - expectedY).toFixed(3)}`);
        console.log(`사용된 원점: ${result.zone} (EPSG:${result.epsg})`);
        
        return result;
      }
      
      // 페이지 로드 시 테스트 실행
      window.addEventListener('load', function() {
        setTimeout(testCoordinateConversion, 1000);
      });
      
      // 좌표로 주소 검색
      async function searchAddressFromCoordinates(lat, lng) {
        try {
          const response = await fetch(`https://dapi.kakao.com/v2/local/geo/coord2address.json?x=${lng}&y=${lat}`, {
            headers: { 
              'Authorization': 'KakaoAK c27024d37ac99abf233b12f0efa39099' 
            }
          });
          
          if (!response.ok) throw new Error('HTTP ' + response.status);
          
          const data = await response.json();
          if (data.documents && data.documents.length > 0) {
            const doc = data.documents[0];
            showAddressInfoWindow(lat, lng, doc);
          } else {
            showAddressInfoWindow(lat, lng, null);
          }
        } catch (error) {
          console.log('주소 검색 오류:', error);
          showAddressInfoWindow(lat, lng, null);
        }
      }
      
      // 주소 정보창 표시 (카카오/구글 공용)
      function showAddressInfoWindow(lat, lng, addressDoc) {
        // 기존 정보창 제거
        clearAddressInfoWindow();
        
        // 한국 좌표계로 변환
        const koreanCoords = convertWGS84ToKoreanTM(lat, lng);
        
        // 정보창 내용 생성 (공통)
        let innerContent = `
            <div style="font-weight: bold; margin-bottom: 8px; color: #000;">
              클릭한 위치
            </div>
            <div style="font-size: 12px; color: #000; margin-bottom: 8px;">
              <strong>${koreanCoords.zone}:</strong><br>
              X: ${koreanCoords.x.toLocaleString()} m<br>
              Y: ${koreanCoords.y.toLocaleString()} m<br>
              <span style="color: #666; font-size: 11px;">EPSG:${koreanCoords.epsg}</span>
            </div>
        `;
        
        if (addressDoc) {
          const jibun = addressDoc.address && addressDoc.address.address_name;
          innerContent += `
            <div style="border-top: 1px solid #000; padding-top: 8px;">
              <div style="font-weight: bold; color: #000; margin-bottom: 4px;">
                지번명 주소
              </div>
              <div style="font-size: 12px; color: #000;">
                ${jibun || '주소 정보 없음'}
              </div>
            </div>
          `;
        } else {
          innerContent += `
            <div style="border-top: 1px solid #000; padding-top: 8px;">
              <div style="font-size: 12px; color: #000;">
                주소 정보를 찾을 수 없습니다.
              </div>
            </div>
          `;
        }
        
        // 모든 맵에서 카카오맵 스타일 사용 (CustomOverlay 형식)
        const customContent = `<div class="custom-info-window">${innerContent}</div>`;
        
        // 활성 맵에 맞춰 정보창 생성 및 표시
        if (isKakaoVisible() && kakaoMap) {
          // 카카오맵에서 CustomOverlay 사용
          addressInfoWindow = new kakao.maps.CustomOverlay({
            content: customContent,
            position: new kakao.maps.LatLng(lat, lng),
            yAnchor: 1,
            xAnchor: 0.5,
            zIndex: 10
          });
          addressInfoWindow.setMap(kakaoMap);
        } else if (map) {
          // 구글맵에서도 카카오맵과 동일한 CustomOverlay 스타일 구현
          class GoogleCustomOverlay extends google.maps.OverlayView {
            constructor(position, content) {
              super();
              this.position = position;
              this.content = content;
              this.div = null;
            }
            
            onAdd() {
              const div = document.createElement('div');
              div.innerHTML = this.content;
              div.style.position = 'absolute';
              div.style.zIndex = '1000';
              div.id = 'googleCustomInfoWindow';
              
              this.div = div;
              const panes = this.getPanes();
              panes.overlayMouseTarget.appendChild(div);
            }
            
            draw() {
              const overlayProjection = this.getProjection();
              const point = overlayProjection.fromLatLngToDivPixel(this.position);
              
              if (point && this.div) {
                this.div.style.left = (point.x - 100) + 'px'; // 중앙 정렬
                this.div.style.top = (point.y - this.div.offsetHeight - 15) + 'px'; // 마커 위에 표시
              }
            }
            
            onRemove() {
              if (this.div && this.div.parentNode) {
                this.div.parentNode.removeChild(this.div);
                this.div = null;
              }
            }
          }
          
          // 기존 오버레이 제거
          if (googleAddressInfoWindow && googleAddressInfoWindow.setMap) {
            googleAddressInfoWindow.setMap(null);
          }
          
          // 새 커스텀 오버레이 생성
          googleAddressInfoWindow = new GoogleCustomOverlay(
            new google.maps.LatLng(lat, lng),
            customContent
          );
          googleAddressInfoWindow.setMap(map);
        }
      }
      
      // 주소 정보창 제거 (카카오/구글 공용)
      function clearAddressInfoWindow() {
        // 카카오
        if (addressInfoWindow) {
          addressInfoWindow.setMap(null);
          addressInfoWindow = null;
        }
        if (addressInfoMarker) {
          addressInfoMarker.setMap(null);
          addressInfoMarker = null;
        }
        // 구글 (CustomOverlay 제거)
        if (googleAddressInfoWindow) {
          if (googleAddressInfoWindow.setMap) {
            googleAddressInfoWindow.setMap(null);
          } else if (googleAddressInfoWindow.close) {
            googleAddressInfoWindow.close();
          }
          googleAddressInfoWindow = null;
        }
        
        if (googleAddressInfoMarker) {
          googleAddressInfoMarker.setMap(null);
          googleAddressInfoMarker = null;
        }
      }
      function onKakaoMapClickForRoadview(mouseEvent) {
        const latlng = mouseEvent.latLng;
        if (!latlng) return;
        showRoadviewAtLatLng(latlng.getLat(), latlng.getLng());
      }

      // 지도 위 로드뷰 오버레이/마커
      function toggleRoadviewOverlay(active) {
        if (!kakaoMap) return;
        if (active) {
          if (!roadviewOverlayOn) {
            kakaoMap.addOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
            roadviewOverlayOn = true;
          }
          // 마커 준비
          if (!roadviewMarker) {
            const markImage = new kakao.maps.MarkerImage(
              'https://t1.daumcdn.net/localimg/localimages/07/2018/pc/roadview_minimap_wk_2018.png',
              new kakao.maps.Size(26, 46),
              {
                spriteSize: new kakao.maps.Size(1666, 168),
                spriteOrigin: new kakao.maps.Point(705, 114),
                offset: new kakao.maps.Point(13, 46)
              }
            );
            roadviewMarker = new kakao.maps.Marker({ image: markImage, draggable: true });
            kakao.maps.event.addListener(roadviewMarker, 'dragend', function() {
              const pos = roadviewMarker.getPosition();
              if (pos) showRoadviewAtLatLng(pos.getLat(), pos.getLng());
            });
          }
          if (roadviewMarker && !roadviewMarker.getMap()) {
            roadviewMarker.setMap(kakaoMap);
            roadviewMarker.setPosition(kakaoMap.getCenter());
          }
        } else {
          if (roadviewOverlayOn) {
            kakaoMap.removeOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
            roadviewOverlayOn = false;
          }
          if (roadviewMarker) roadviewMarker.setMap(null);
          hideRoadview();
        }
      }
      function updateRoadviewMarkerPosition(latlng) {
        if (!kakaoMap) return;
        if (roadviewMarker && roadviewOverlayOn) {
          roadviewMarker.setMap(kakaoMap);
          roadviewMarker.setPosition(latlng);
        }
      }
      function syncMarkersToKakao() {
        try {
          if (!kakaoMap) return;
          
          // 기존 카카오 마커 제거
          if (kakaoMarkers && kakaoMarkers.length) {
            kakaoMarkers.forEach(m => {
              try {
                if (m && m.setMap) m.setMap(null);
              } catch (e) { /* ignore individual marker errors */ }
            });
            kakaoMarkers = [];
          }
          
          // 구글 마커를 카카오 마커로 복제
          if (addressMarkers && addressMarkers.length) {
            addressMarkers.forEach(gm => {
              try {
                if (!gm || !gm.getPosition) return;
                
                const pos = gm.getPosition();
                if (!pos) return;
                
                const lat = typeof pos.lat === 'function' ? pos.lat() : (pos.lat || null);
                const lng = typeof pos.lng === 'function' ? pos.lng() : (pos.lng || null);
                
                if (lat == null || lng == null) return;
                
                const marker = new kakao.maps.Marker({
                  position: new kakao.maps.LatLng(lat, lng),
                  map: kakaoMap
                });
                
                kakao.maps.event.addListener(marker, 'click', function() { 
                  removeSpecificKakaoMarker(marker); 
                });
                
                kakaoMarkers.push(marker);
              } catch (e) { 
                console.log('개별 마커 동기화 오류:', e);
              }
            });
          }
        } catch (e) {
          console.log('마커 동기화 중 오류:', e);
        }
      }
      function getCurrentCenter() {
        let centerLat = 37.5665;
        let centerLng = 126.9780;
        
        try {
          if (map && map.getCenter) {
            const c = map.getCenter();
            if (c) {
              centerLat = (typeof c.lat === 'function') ? c.lat() : c.lat;
              centerLng = (typeof c.lng === 'function') ? c.lng() : c.lng;
            }
          }
        } catch (e) {
          console.log('구글맵 중심점 가져오기 오류:', e);
        }
        
        return { lat: centerLat, lng: centerLng };
      }
      async function searchAddress() {
        const query = document.getElementById('addressInput').value;
        if (!query) {
          alert('검색어를 입력하세요.');
          return;
        }

        try {
          // 1) 장소(키워드) 검색을 우선 시도
          let centerLng = null;
          let centerLat = null;
          if (map && map.getCenter) {
            const c = map.getCenter();
            if (c) {
              centerLat = typeof c.lat === 'function' ? c.lat() : c.lat;
              centerLng = typeof c.lng === 'function' ? c.lng() : c.lng;
            }
          }

          const keywordParams = new URLSearchParams({ query, size: '15' });
          if (centerLng != null && centerLat != null) {
            keywordParams.set('x', String(centerLng));
            keywordParams.set('y', String(centerLat));
            keywordParams.set('radius', '20000'); // 20km 우선
          }
          const keywordUrl = 'https://dapi.kakao.com/v2/local/search/keyword.json?' + keywordParams.toString();
          let res = await fetch(keywordUrl, {
            headers: { Authorization: 'KakaoAK c27024d37ac99abf233b12f0efa39099' }
          });
          if (!res.ok) throw new Error('HTTP ' + res.status + ' (keyword)');
          let data = await res.json();
          let documents = Array.isArray(data && data.documents) ? data.documents : [];
          let usedMode = 'keyword';

          // 2) 키워드 결과가 없으면 지도 위치 제약 없이 전국 검색 재시도
          if (documents.length === 0) {
            const globalKeywordUrl = 'https://dapi.kakao.com/v2/local/search/keyword.json?query=' + encodeURIComponent(query) + '&size=15';
            res = await fetch(globalKeywordUrl, {
              headers: { Authorization: 'KakaoAK c27024d37ac99abf233b12f0efa39099' }
            });
            if (!res.ok) throw new Error('HTTP ' + res.status + ' (keyword-global)');
            data = await res.json();
            documents = Array.isArray(data && data.documents) ? data.documents : [];
          }

          // 3) 그래도 없으면 주소 검색으로 폴백
          if (documents.length === 0) {
            const addressUrl = 'https://dapi.kakao.com/v2/local/search/address.json?query=' + encodeURIComponent(query);
            res = await fetch(addressUrl, {
              headers: { Authorization: 'KakaoAK c27024d37ac99abf233b12f0efa39099' }
            });
            if (!res.ok) throw new Error('HTTP ' + res.status + ' (address)');
            data = await res.json();
            documents = Array.isArray(data && data.documents) ? data.documents : [];
            usedMode = 'address';
          }

          if (!documents || documents.length === 0) {
            alert('검색 결과가 없습니다.');
            return;
          }

          // 3) 결과 목록을 패널에 렌더링하고 사용자 선택을 기다림
          showSearchResults(documents, usedMode);
        } catch (e) {
          alert('검색 중 오류가 발생했습니다: ' + e.message);
        }
      }

      function showSearchResults(documents, mode) {
        lastSearchResults = documents.slice(0, 20);
        lastSearchMode = mode;
        const list = document.getElementById('searchResultsList');
        if (!list) return;
        list.innerHTML = '';
        lastSearchResults.forEach((doc, idx) => {
          const item = document.createElement('div');
          item.className = 'search-result-item';
          item.dataset.index = String(idx);
          const title = mode === 'keyword' ? (doc.place_name || '') : (doc.address_name || '');
          const sub = mode === 'keyword' ? (doc.road_address_name || doc.address_name || '') : ((doc.road_address && doc.road_address.address_name) || '');
          item.innerHTML = `
            <p class="result-title">${idx + 1}. ${title || '(이름 없음)'}</p>
            <p class="result-sub">${sub}</p>
          `;
          item.addEventListener('click', () => selectSearchResult(idx));
          list.appendChild(item);
        });
        const panel = document.getElementById('searchResultsPanel');
        if (panel) panel.style.display = 'block';
      }

      function hideSearchResults() {
        const panel = document.getElementById('searchResultsPanel');
        if (panel) panel.style.display = 'none';
        const list = document.getElementById('searchResultsList');
        if (list) list.innerHTML = '';
        lastSearchResults = [];
      }

      function selectSearchResult(index) {
        const doc = lastSearchResults[index];
        if (!doc) return;
        const lat = parseFloat(doc.y);
        const lng = parseFloat(doc.x);
        if (isNaN(lat) || isNaN(lng)) return;
        const position = { lat, lng };

        const title = lastSearchMode === 'keyword' ? (doc.place_name || '') : (doc.address_name || '');

        if (isKakaoVisible() && kakaoMap) {
          kakaoMap.setCenter(new kakao.maps.LatLng(position.lat, position.lng));
          // 구글 줌 16과 유사한 카카오 레벨로 설정
          kakaoMap.setLevel(googleZoomToKakaoLevel(16));
          const marker = new kakao.maps.Marker({
            position: new kakao.maps.LatLng(position.lat, position.lng),
            map: kakaoMap,
            title
          });
          kakao.maps.event.addListener(marker, 'click', function() { removeSpecificKakaoMarker(marker); });
          kakaoMarkers.push(marker);
        } else {
          map.setCenter(position);
          map.setZoom(16);
          const newMarker = new google.maps.Marker({
            position,
            map,
            title,
            animation: google.maps.Animation.DROP
          });
          newMarker.addListener('click', function () { removeSpecificMarker(newMarker); });
          addressMarkers.push(newMarker);
        }

        hideSearchResults();
      }
      
      // 특정 마커 제거 함수
      function removeSpecificMarker(marker) {
        if (marker) {
          marker.setMap(null);
          // 배열에서 해당 마커 제거
          const index = addressMarkers.indexOf(marker);
          if (index > -1) {
            addressMarkers.splice(index, 1);
          }
        }
      }
      function removeSpecificKakaoMarker(marker) {
        if (marker) {
          marker.setMap && marker.setMap(null);
          const idx = kakaoMarkers.indexOf(marker);
          if (idx > -1) kakaoMarkers.splice(idx, 1);
        }
      }
      
      // 모든 주소 마커 제거 함수
      function clearAllAddressMarkers() {
        addressMarkers.forEach(marker => {
          marker.setMap(null);
        });
        addressMarkers = [];
        if (kakaoMarkers && kakaoMarkers.length) {
          kakaoMarkers.forEach(m => m.setMap && m.setMap(null));
          kakaoMarkers = [];
        }
        document.getElementById('addressInput').value = '';
      }
      // 사이드 패널 토글 함수
      function hideMenu() {
        getElement('customMapMenu').classList.add('hide');
        getElement('menuToggleBtn').classList.add('show');
      }
      function showMenu() {
        getElement('customMapMenu').classList.remove('hide');
        getElement('menuToggleBtn').classList.remove('show');
      }
      
      // 브이월드 경계 메뉴 토글
      function toggleVworldBoundaryMenu() {
        toggleMenu('vworldBoundaryMenu', 'vworldBoundaryToggleBtn', '법정경계');
      }
      
      // 브이월드 경계 로드 함수
      function loadVworldBoundary(layerType) {
        if (!map) {
          alert('지도가 아직 준비되지 않았습니다.');
          return;
        }
        
        // 현재 지도 zoom 값 확인
        const zoom = map.getZoom();
        if (zoom > CONFIG.MAX_BOUNDARY_ZOOM) {
          alert(`이 경계는 더 이상 확대할 수 없습니다. (최대 허용 zoom: ${CONFIG.MAX_BOUNDARY_ZOOM})`);
          return;
        }
        
        showGoogleMap();
        clearVworldBoundary();
        
        const bounds = map.getBounds();
        if (!bounds) {
          alert('지도 영역을 확정할 수 없습니다. 지도를 이동한 후 다시 시도해주세요.');
          return;
        }
        
        const ne = bounds.getNorthEast();
        const sw = bounds.getSouthWest();
        
        // EPSG:4326의 경우 (ymin,xmin,ymax,xmax) 형식
        const bbox = `${sw.lat()},${sw.lng()},${ne.lat()},${ne.lng()}`;
        
        // map div의 실제 크기 사용
        const mapDiv = document.getElementById('map');
        const width = mapDiv.offsetWidth;
        const height = mapDiv.offsetHeight;
        
        // 브이월드 공식 WMS API URL 생성
        const apiUrl = 'https://api.vworld.kr/req/wms';
        const params = new URLSearchParams({
          key: '46F4304E-84DC-3F56-92F1-6A98A0370A31', // 본인 키로 교체
          service: 'WMS',
          request: 'GetMap',
          version: '1.3.0',
          layers: layerType, // 공식 WMS명
          styles: '', // 필요시 스타일명 입력
          crs: 'EPSG:4326',
          bbox: bbox,
          width: width,
          height: height,
          format: 'image/png',
          transparent: 'true',
          exceptions: 'text/xml'
        });
        const fullUrl = `${apiUrl}?${params.toString()}`;

        // 이미지 오버레이 생성
        const imageBounds = new google.maps.LatLngBounds(
          new google.maps.LatLng(sw.lat(), sw.lng()),
          new google.maps.LatLng(ne.lat(), ne.lng())
        );

        vworldBoundaryOverlay = new google.maps.GroundOverlay(fullUrl, imageBounds, {
          opacity: 0.95,
          clickable: false
        });

        vworldBoundaryOverlay.setMap(map);
        currentBoundaryLayer = layerType;

        // 메뉴 상태 업데이트
        updateBoundaryMenuState(layerType);
      }
      
      // 브이월드 경계 제거 함수
      function clearVworldBoundary() {
        if (vworldBoundaryOverlay) {
          vworldBoundaryOverlay.setMap(null);
          vworldBoundaryOverlay = null;
        }
        currentBoundaryLayer = null;
        updateBoundaryMenuState(null);
      }
      
      // 경계 메뉴 상태 업데이트
      function updateBoundaryMenuState(activeLayer) {
        const buttons = document.querySelectorAll('#vworldBoundaryMenu button');
        buttons.forEach(btn => {
          btn.style.background = '#f7f7f7';
          btn.style.color = '#333';
        });
        
        if (activeLayer) {
          const activeBtn = document.querySelector(`#vworldBoundaryMenu button[onclick*="${activeLayer}"]`);
          if (activeBtn) {
            activeBtn.style.background = '#e0e7ff';
            activeBtn.style.color = '#1d4ed8';
          }
        }
      }
      
      // 경계 오버레이 업데이트 함수
      function updateBoundaryOverlay() {
        if (!currentBoundaryLayer || !map) return;
        
        // 현재 지도 zoom 값 확인
        const zoom = map.getZoom();
        const MAX_BOUNDARY_ZOOM = 32;
        if (zoom > MAX_BOUNDARY_ZOOM) {
          clearVworldBoundary();
          alert('이 경계는 더 이상 확대할 수 없습니다. (최대 허용 zoom: ' + MAX_BOUNDARY_ZOOM + ')');
          return;
        }
        
        const bounds = map.getBounds();
        if (!bounds) return;
        
        const ne = bounds.getNorthEast();
        const sw = bounds.getSouthWest();
        
        // EPSG:4326의 경우 (ymin,xmin,ymax,xmax) 형식
        const bbox = `${sw.lat()},${sw.lng()},${ne.lat()},${ne.lng()}`;
        
        // map div의 실제 크기 사용
        const mapDiv = document.getElementById('map');
        const width = mapDiv.offsetWidth;
        const height = mapDiv.offsetHeight;
        
        // 브이월드 공식 WMS API URL 생성
        const apiUrl = 'https://api.vworld.kr/req/wms';
        const params = new URLSearchParams({
          key: '46F4304E-84DC-3F56-92F1-6A98A0370A31',
          service: 'WMS',
          request: 'GetMap',
          version: '1.3.0',
          layers: currentBoundaryLayer,
          styles: '',
          crs: 'EPSG:4326',
          bbox: bbox,
          width: width,
          height: height,
          format: 'image/png',
          transparent: 'true',
          exceptions: 'text/xml'
        });
        const fullUrl = `${apiUrl}?${params.toString()}`;

        // 기존 오버레이 제거
        if (vworldBoundaryOverlay) {
          vworldBoundaryOverlay.setMap(null);
        }

        // 새로운 이미지 오버레이 생성
        const imageBounds = new google.maps.LatLngBounds(
          new google.maps.LatLng(sw.lat(), sw.lng()),
          new google.maps.LatLng(ne.lat(), ne.lng())
        );

        vworldBoundaryOverlay = new google.maps.GroundOverlay(fullUrl, imageBounds, {
          opacity: 0.95,
          clickable: false
        });

        vworldBoundaryOverlay.setMap(map);
      }
      async function loadCadastralOverlay() {
        if (isKakaoVisible()) { await loadCadastralOverlayKakao(); return; }
        if (!map) { alert('지도가 아직 준비되지 않았습니다.'); return; }
        clearCadastralOverlay();
        const b = map.getBounds(); if (!b) { alert('지도 영역을 확정할 수 없습니다.'); return; }
        const ne = b.getNorthEast(); const sw = b.getSouthWest();
        const bbox = `${sw.lat()},${sw.lng()},${ne.lat()},${ne.lng()},EPSG:4326`;
        try {
          const features = await fetchCadastralWfs(bbox);
          renderCadastralGoogle(features);
          updateCadastralButtonState(true);
        } catch (e) {
          alert('연속지적도(WFS) 로드 실패: ' + e.message);
        }
      }
      function clearCadastralOverlay() {
        // 카카오 지적도 제거 우선 처리
        if (kakaoCadastralOverlayEl) {
          clearCadastralOverlayKakao();
        }
        if (cadastralOverlay) {
          cadastralOverlay.setMap(null);
          cadastralOverlay = null;
        }
        // 구글 지적도 모드 해제
        if (cadastralOverlayMode === 'google') {
          cadastralOverlayMode = null;
        }
        // 버튼 상태 업데이트
        updateCadastralButtonState(false);
      }
      
      // 연속지적도 토글 함수
      function toggleCadastralOverlay() {
        if (isKakaoVisible()) {
          // 카카오맵 표시 상태
          if (kakaoCadastralOverlayEl) {
            clearCadastralOverlayKakao();
          } else {
            loadCadastralOverlayKakao();
          }
        } else {
          // 구글맵 표시 상태
          if (cadastralOverlay) {
            clearCadastralOverlay();
          } else {
            loadCadastralOverlay();
          }
        }
      }
      
      // 연속지적도 버튼 상태 업데이트 함수
      function updateCadastralButtonState(isLoaded) {
        const btn = document.getElementById('cadastralToggleBtn');
        if (isLoaded) {
          btn.textContent = '-지적도제거';
          btn.style.background = '#e0e7ff';
          btn.style.color = '#1d4ed8';
        } else {
          btn.textContent = '+연속지적도';
          btn.style.background = '#f7f7f7';
          btn.style.color = '#333';
        }
      }

      // 지적도근점 토글/로드/제거/갱신 (구글)
      function toggleControlPointOverlay() {
        if (isKakaoVisible()) {
          if (kakaoControlPointOverlayEl) {
            clearControlPointOverlayKakao();
          } else {
            loadControlPointOverlayKakao();
          }
        } else {
          if (controlPointOverlay) {
            clearControlPointOverlay();
          } else {
            loadControlPointOverlay();
          }
        }
      }

      function updateControlPointButtonState(isLoaded) {
        const btn = document.getElementById('controlPointToggleBtn');
        if (!btn) return;
        if (isLoaded) {
          btn.textContent = '-지적도근점제거';
          btn.style.background = '#e0e7ff';
          btn.style.color = '#1d4ed8';
        } else {
          btn.textContent = '+지적도근점';
          btn.style.background = '#f7f7f7';
          btn.style.color = '#333';
        }
      }

      async function loadControlPointOverlay() {
        if (isKakaoVisible()) { await loadControlPointOverlayKakao(); return; }
        if (!map) { alert('지도가 아직 준비되지 않았습니다.'); return; }
        clearControlPointOverlay();
        const b = map.getBounds(); if (!b) { alert('지도 영역을 확정할 수 없습니다.'); return; }
        const ne = b.getNorthEast(); const sw = b.getSouthWest();
        const bbox = `${sw.lat()},${sw.lng()},${ne.lat()},${ne.lng()},EPSG:4326`;
        try {
          const feats = await fetchControlPointWfs(bbox);
          renderControlPointsGoogle(feats);
          updateControlPointButtonState(true);
        } catch (e) {
          alert('지적도근점(WFS) 로드 실패: ' + e.message);
        }
      }

      async function updateControlPointOverlay() {
        if (isKakaoVisible()) { await updateControlPointOverlayKakao(); return; }
        if (!map) return;
        const b = map.getBounds(); if (!b) return;
        const ne = b.getNorthEast(); const sw = b.getSouthWest();
        const bbox = `${sw.lat()},${sw.lng()},${ne.lat()},${ne.lng()},EPSG:4326`;
        try {
          const feats = await fetchControlPointWfs(bbox);
          renderControlPointsGoogle(feats);
        } catch (e) { /* ignore */ }
      }

      function clearControlPointOverlay() {
        if (controlPointOverlay) {
          controlPointOverlay.setMap(null);
          controlPointOverlay = null;
        }
        if (controlPointOverlayMode === 'google') controlPointOverlayMode = null;
        updateControlPointButtonState(false);
      }

      // 지적도근점(카카오)
      async function loadControlPointOverlayKakao() {
        if (!kakaoMap) { alert('카카오맵이 아직 준비되지 않았습니다.'); return; }
        clearControlPointOverlayKakao();
        const b = kakaoMap.getBounds(); if (!b) return;
        const sw = b.getSouthWest(); const ne = b.getNorthEast();
        const bbox = `${sw.getLat()},${sw.getLng()},${ne.getLat()},${ne.getLng()},EPSG:4326`;
        try {
          const feats = await fetchControlPointWfs(bbox);
          renderControlPointsKakao(feats);
          controlPointOverlayMode = 'kakao';
          updateControlPointButtonState(true);
        } catch (e) {
          alert('지적도근점(WFS) 로드 실패: ' + e.message);
        }
      }

      async function updateControlPointOverlayKakao() {
        if (!kakaoMap) return;
        const b = kakaoMap.getBounds(); if (!b) return;
        const sw = b.getSouthWest(); const ne = b.getNorthEast();
        const bbox = `${sw.getLat()},${sw.getLng()},${ne.getLat()},${ne.getLng()},EPSG:4326`;
        try {
          const feats = await fetchControlPointWfs(bbox);
          renderControlPointsKakao(feats);
        } catch (e) { /* ignore */ }
      }

      // 구글 GroundOverlay에 나타나는 지적도근점 이미지에 마젠타 필터를 적용
      function applyControlPointMagentaFilter() {
        try {
          let attempts = 0;
          const maxAttempts = 10;
          const tryApply = () => {
            attempts++;
            const imgs = document.querySelectorAll('img[src*="api.vworld.kr"]');
            let applied = false;
            imgs.forEach(img => {
              const src = img.getAttribute('src') || '';
              if (src.includes('dt_d007')) {
                img.style.filter = 'invert(14%) sepia(98%) saturate(7479%) hue-rotate(293deg) brightness(82%) contrast(111%)';
                applied = true;
              }
            });
            if (!applied && attempts < maxAttempts) {
              setTimeout(tryApply, 400);
            }
          };
          tryApply();

          // 변화 감지 중 짧게 유지
          const mapEl = document.getElementById('map');
          if (!mapEl) return;
          const observer = new MutationObserver(muts => {
            muts.forEach(m => {
              m.addedNodes.forEach(n => {
                if (n.nodeType === 1) {
                  if (n.tagName === 'IMG') {
                    const src = n.getAttribute('src') || '';
                    if (src.includes('api.vworld.kr') && src.includes('dt_d007')) {
                      n.style.filter = 'invert(14%) sepia(98%) saturate(7479%) hue-rotate(293deg) brightness(82%) contrast(111%)';
                    }
                  } else if (n.querySelectorAll) {
                    n.querySelectorAll('img[src*="api.vworld.kr"]').forEach(img => {
                      const src = img.getAttribute('src') || '';
                      if (src.includes('dt_d007')) {
                        img.style.filter = 'invert(14%) sepia(98%) saturate(7479%) hue-rotate(293deg) brightness(82%) contrast(111%)';
                      }
                    });
                  }
                }
              });
            });
          });
          observer.observe(mapEl, { childList: true, subtree: true });
          setTimeout(() => observer.disconnect(), 5000);
        } catch (e) {
          // 무시
        }
      }

      // ---------- WFS 공통 유틸 ----------
      async function fetchCadastralWfs(bboxStr) {
        const params = new URLSearchParams({
          service: 'WFS', version: '1.1.0', request: 'GetFeature',
          typename: 'dt_d002', srsName: 'EPSG:4326', bbox: bboxStr,
          output: 'application/json', key: CONFIG.VWORLD_API_KEY
        });
        const url = `${CONFIG.VWORLD_CADASTRAL_WFS_URL}?${params.toString()}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        return Array.isArray(data.features) ? data.features : [];
      }

      async function fetchControlPointWfs(bboxStr) {
        const params = new URLSearchParams({
          service: 'WFS', version: '1.1.0', request: 'GetFeature',
          typename: 'dt_d007', srsName: 'EPSG:4326', bbox: bboxStr,
          output: 'application/json', key: CONFIG.VWORLD_API_KEY
        });
        const url = `${CONFIG.VWORLD_CONTROL_POINT_WFS_URL}?${params.toString()}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        return Array.isArray(data.features) ? data.features : [];
      }

      function pickControlPointLabel(props) {
        if (!props) return '근점';
        const candidates = ['name', 'nm', 'label', 'text', 'pnt_name', 'point_name'];
        for (const k of candidates) {
          if (props[k]) return String(props[k]);
        }
        return '근점';
      }

      // ---------- WFS 렌더링: 구글(연속지적도) ----------
      function renderCadastralGoogle(features) {
        if (googleCadastralDataLayer) {
          try { googleCadastralDataLayer.setMap(null); } catch(_){}
          googleCadastralDataLayer = null;
        }
        if (!map || !features || !features.length) return;
        googleCadastralDataLayer = new google.maps.Data({ map });
        const geojson = { type: 'FeatureCollection', features };
        try { googleCadastralDataLayer.addGeoJson(geojson); } catch(_){}
        googleCadastralDataLayer.setStyle({
          strokeColor: '#e11d48', strokeOpacity: 0.9, strokeWeight: 2,
          fillColor: '#e11d48', fillOpacity: 0.06
        });
        // 상태 플래그 갱신
        cadastralOverlayMode = 'google';
      }

      // ---------- WFS 렌더링: 카카오(연속지적도) ----------
      function renderCadastralKakao(features) {
        // 기존 폴리곤 제거
        if (kakaoCadastralPolygons && kakaoCadastralPolygons.length) {
          kakaoCadastralPolygons.forEach(p => { try { p.setMap(null); } catch(_){} });
        }
        kakaoCadastralPolygons = [];
        if (!kakaoMap || !features || !features.length) return;
        const strokeColor = '#e11d48';
        const fillColor = '#e11d48';
        features.forEach(f => {
          const geom = f && f.geometry;
          if (!geom || !geom.type || !geom.coordinates) return;
          const makePoly = (rings) => {
            const paths = rings.map(r => r.map(([lng,lat]) => new kakao.maps.LatLng(lat, lng)));
            const poly = new kakao.maps.Polygon({
              path: paths,
              strokeWeight: 2, strokeColor, strokeOpacity: 0.9, strokeStyle: 'solid',
              fillColor, fillOpacity: 0.06
            });
            poly.setMap(kakaoMap);
            kakaoCadastralPolygons.push(poly);
          };
          if (geom.type === 'Polygon') {
            makePoly(geom.coordinates);
          } else if (geom.type === 'MultiPolygon') {
            geom.coordinates.forEach(rings => makePoly(rings));
          } else if (geom.type === 'LineString') {
            const path = geom.coordinates.map(([lng,lat]) => new kakao.maps.LatLng(lat, lng));
            const pl = new kakao.maps.Polyline({ path, strokeWeight: 2, strokeColor, strokeOpacity: 0.9 });
            pl.setMap(kakaoMap); kakaoCadastralPolygons.push(pl);
          } else if (geom.type === 'MultiLineString') {
            geom.coordinates.forEach(line => {
              const path = line.map(([lng,lat]) => new kakao.maps.LatLng(lat, lng));
              const pl = new kakao.maps.Polyline({ path, strokeWeight: 2, strokeColor, strokeOpacity: 0.9 });
              pl.setMap(kakaoMap); kakaoCadastralPolygons.push(pl);
            });
          }
        });
      }

      // ---------- WFS 렌더링: 구글(지적도근점) ----------
      function renderControlPointsGoogle(features) {
        // 기존 제거
        if (googleControlPointOverlays && googleControlPointOverlays.length) {
          googleControlPointOverlays.forEach(o => { try { o.setMap(null); } catch(_){} });
        }
        googleControlPointOverlays = [];
        if (!map || !features || !features.length) return;
        features.forEach(f => {
          const g = f.geometry; if (!g || g.type !== 'Point' || !Array.isArray(g.coordinates)) return;
          const lng = g.coordinates[0], lat = g.coordinates[1];
          const label = pickControlPointLabel(f.properties);
          const overlay = new (class extends google.maps.OverlayView {
            constructor(position, label) { super(); this.position = position; this.label = label; this.div = null; }
            onAdd() {
              const div = document.createElement('div');
              div.style.position = 'absolute'; div.style.transform = 'translate(-8px, -8px)'; div.style.pointerEvents = 'none';
              const circle = document.createElement('div'); circle.style.width = '16px'; circle.style.height = '16px'; circle.style.borderRadius = '50%';
              circle.style.background = '#b0006f'; circle.style.boxShadow = '0 0 0 2px #fff'; circle.style.display = 'inline-block';
              const span = document.createElement('span'); span.textContent = this.label || '';
              span.style.position = 'relative'; span.style.left = '8px'; span.style.top = '-2px'; span.style.padding = '2px 4px';
              span.style.background = 'rgba(255,255,255,0.9)'; span.style.borderRadius = '4px'; span.style.color = '#b0006f'; span.style.fontSize = '12px'; span.style.fontWeight = '700'; span.style.whiteSpace = 'nowrap';
              div.appendChild(circle); div.appendChild(span);
              this.div = div; this.getPanes().overlayMouseTarget.appendChild(div);
            }
            draw() { const p = this.getProjection().fromLatLngToDivPixel(this.position); if (p && this.div) { this.div.style.left = `${p.x}px`; this.div.style.top = `${p.y}px`; } }
            onRemove() { if (this.div && this.div.parentNode) this.div.parentNode.removeChild(this.div); this.div = null; }
          })(new google.maps.LatLng(lat, lng), label);
          overlay.setMap(map);
          googleControlPointOverlays.push(overlay);
        });
        controlPointOverlayMode = 'google';
      }

      // ---------- WFS 렌더링: 카카오(지적도근점) ----------
      function renderControlPointsKakao(features) {
        if (kakaoControlPointOverlays && kakaoControlPointOverlays.length) {
          kakaoControlPointOverlays.forEach(o => { try { o.setMap(null); } catch(_){} });
        }
        kakaoControlPointOverlays = [];
        if (!kakaoMap || !features || !features.length) return;
        features.forEach(f => {
          const g = f.geometry; if (!g || g.type !== 'Point' || !Array.isArray(g.coordinates)) return;
          const lng = g.coordinates[0], lat = g.coordinates[1];
          const label = pickControlPointLabel(f.properties);
          const content = document.createElement('div'); content.style.position = 'relative'; content.style.transform = 'translate(-8px, -8px)'; content.style.pointerEvents = 'none';
          const circle = document.createElement('div'); circle.style.width = '16px'; circle.style.height = '16px'; circle.style.borderRadius = '50%'; circle.style.background = '#b0006f'; circle.style.boxShadow = '0 0 0 2px #fff'; circle.style.display = 'inline-block';
          const span = document.createElement('span'); span.textContent = label; span.style.position = 'relative'; span.style.left = '8px'; span.style.top = '-2px'; span.style.padding = '2px 4px'; span.style.background = 'rgba(255,255,255,0.9)'; span.style.borderRadius = '4px'; span.style.color = '#b0006f'; span.style.fontSize = '12px'; span.style.fontWeight = '700'; span.style.whiteSpace = 'nowrap';
          content.appendChild(circle); content.appendChild(span);
          const overlay = new kakao.maps.CustomOverlay({ content, position: new kakao.maps.LatLng(lat, lng), xAnchor: 0.5, yAnchor: 0.5, zIndex: 7 });
          overlay.setMap(kakaoMap);
          kakaoControlPointOverlays.push(overlay);
        });
        controlPointOverlayMode = 'kakao';
      }

      function clearControlPointOverlayKakao() {
        if (kakaoControlPointOverlays && kakaoControlPointOverlays.length) {
          kakaoControlPointOverlays.forEach(o => { try { o.setMap(null); } catch(_){} });
          kakaoControlPointOverlays = [];
        }
        if (controlPointOverlayMode === 'kakao') controlPointOverlayMode = null;
        updateControlPointButtonState(false);
      }
      // 지도 이동 시 연속지적도 오버레이도 갱신
      map && map.addListener && map.addListener('bounds_changed', function() {
        if (cadastralOverlay) {
                      setTimeout(() => {
            updateCadastralOverlay();
          }, 1000);
        }
      });
      async function updateCadastralOverlay() {
        if (isKakaoVisible()) { await updateCadastralOverlayKakao(); return; }
        if (!map) return;
        const b = map.getBounds(); if (!b) return;
        const ne = b.getNorthEast(); const sw = b.getSouthWest();
        const bbox = `${sw.lat()},${sw.lng()},${ne.lat()},${ne.lng()},EPSG:4326`;
        try {
          const features = await fetchCadastralWfs(bbox);
          renderCadastralGoogle(features);
        } catch (e) {
          // 무시
        }
      }
      // 카카오 지적도 로드/업데이트/제거
      function loadCadastralOverlayKakao() {
        if (!kakaoMap) { alert('카카오맵이 아직 준비되지 않았습니다.'); return; }
        const mapDiv = document.getElementById('kakaoMapDiv');
        if (!mapDiv) return;
        const bounds = kakaoMap.getBounds();
        if (!bounds) return;
        const sw = bounds.getSouthWest();
        const ne = bounds.getNorthEast();
        const bbox = `${sw.getLat()},${sw.getLng()},${ne.getLat()},${ne.getLng()}`;
        const width = mapDiv.offsetWidth;
        const height = mapDiv.offsetHeight;
        const apiUrl = 'https://api.vworld.kr/req/wms';
        const params = new URLSearchParams({
          KEY: '46F4304E-84DC-3F56-92F1-6A98A0370A31',
          SERVICE: 'WMS',
          REQUEST: 'GetMap',
          VERSION: '1.3.0',
          LAYERS: 'lp_pa_cbnd_bonbun,lp_pa_cbnd_bubun',
          STYLES: '',
          CRS: 'EPSG:4326',
          BBOX: bbox,
          WIDTH: String(width),
          HEIGHT: String(height),
          FORMAT: 'image/png',
          TRANSPARENT: 'true',
          BGCOLOR: '0xFFFFFF',
          DPI: '96',
          EXCEPTIONS: 'text/xml'
        });
        const fullUrl = `${apiUrl}?${params.toString()}`;

        if (!kakaoCadastralOverlayEl) {
          const overlay = document.createElement('div');
          overlay.id = 'kakaoCadastralOverlay';
          overlay.style.position = 'absolute';
          overlay.style.top = '0';
          overlay.style.left = '0';
          overlay.style.width = '100%';
          overlay.style.height = '100%';
          overlay.style.pointerEvents = 'none';
          overlay.style.zIndex = '6';
          const img = document.createElement('img');
          img.id = 'kakaoCadastralImage';
          img.style.width = '100%';
          img.style.height = '100%';
          img.style.imageRendering = 'crisp-edges';
          img.style.filter = 'contrast(1.2) brightness(1.1) hue-rotate(240deg) saturate(2)';
          img.style.mixBlendMode = 'multiply';
          overlay.appendChild(img);
          const container = document.getElementById('kakaoMapContainer');
          container && container.appendChild(overlay);
          kakaoCadastralOverlayEl = overlay;

          // 지도 이동/확대 시 갱신
          kakao.maps.event.addListener(kakaoMap, 'idle', function() {
            if (cadastralOverlayMode === 'kakao') {
              setTimeout(() => updateCadastralOverlayKakao(), 1000);
            }
          });
        }
        const imgEl = document.getElementById('kakaoCadastralImage');
        if (imgEl) imgEl.src = fullUrl;
        cadastralOverlayMode = 'kakao';
        updateCadastralButtonState(true);
      }
      function updateCadastralOverlayKakao() {
        if (!kakaoMap || !kakaoCadastralOverlayEl) return;
        const mapDiv = document.getElementById('kakaoMapDiv');
        if (!mapDiv) return;
        const bounds = kakaoMap.getBounds();
        if (!bounds) return;
        const sw = bounds.getSouthWest();
        const ne = bounds.getNorthEast();
        const bbox = `${sw.getLat()},${sw.getLng()},${ne.getLat()},${ne.getLng()}`;
        const width = mapDiv.offsetWidth;
        const height = mapDiv.offsetHeight;
        const apiUrl = 'https://api.vworld.kr/req/wms';
        const params = new URLSearchParams({
          KEY: '910896AA-BE88-363C-B54B-9FB421BD05DB',
          SERVICE: 'WMS',
          REQUEST: 'GetMap',
          VERSION: '1.3.0',
          LAYERS: 'lp_pa_cbnd_bonbun,lp_pa_cbnd_bubun',
          STYLES: '',
          CRS: 'EPSG:4326',
          BBOX: bbox,
          WIDTH: String(width),
          HEIGHT: String(height),
          FORMAT: 'image/png',
          TRANSPARENT: 'true',
          BGCOLOR: '0xFFFFFF',
          DPI: '96',
          EXCEPTIONS: 'text/xml'
        });
        const fullUrl = `${apiUrl}?${params.toString()}`;
        const imgEl = document.getElementById('kakaoCadastralImage');
        if (imgEl) imgEl.src = fullUrl;
      }
      function clearCadastralOverlayKakao() {
        if (kakaoCadastralOverlayEl) {
          kakaoCadastralOverlayEl.remove();
          kakaoCadastralOverlayEl = null;
        }
        if (cadastralOverlayMode === 'kakao') {
          cadastralOverlayMode = null;
        }
        updateCadastralButtonState(false);
      }
      
      // 지적도 빨간색 필터 적용 함수
      function applyCadastralRedFilter() {
        // 여러 번 시도하여 DOM 요소를 찾아 스타일 적용
        let attempts = 0;
        const maxAttempts = 10;
        
        const applyFilter = () => {
          attempts++;
          
          // 구글맵의 GroundOverlay 이미지 찾기
          const overlayElements = document.querySelectorAll('img[src*="api.vworld.kr"]');
          let found = false;
          
          overlayElements.forEach(img => {
            if (img.src.includes('lp_pa_cbnd')) {
              img.style.filter = 'contrast(1.2) brightness(1.1) hue-rotate(240deg) saturate(2)';
              img.style.mixBlendMode = 'multiply';
              found = true;
            }
          });
          
          // MutationObserver를 사용하여 새로 추가되는 이미지 감지
          if (!found && attempts < maxAttempts) {
            setTimeout(applyFilter, 500);
          } else if (found) {
            // 성공적으로 적용됨
            console.log('지적도 빨간색 필터 적용 완료');
          }
        };
        
        // 즉시 시도
        applyFilter();
        
        // MutationObserver로 DOM 변화 감지
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === 1 && node.tagName === 'IMG') {
                const img = node;
                if (img.src && img.src.includes('api.vworld.kr') && img.src.includes('lp_pa_cbnd')) {
                  img.style.filter = 'contrast(1.2) brightness(1.1) hue-rotate(240deg) saturate(2)';
                  img.style.mixBlendMode = 'multiply';
                }
              }
              // 하위 img 요소들도 확인
              if (node.nodeType === 1 && node.querySelectorAll) {
                const imgs = node.querySelectorAll('img[src*="api.vworld.kr"]');
                imgs.forEach(img => {
                  if (img.src.includes('lp_pa_cbnd')) {
                    img.style.filter = 'contrast(1.2) brightness(1.1) hue-rotate(240deg) saturate(2)';
                    img.style.mixBlendMode = 'multiply';
                  }
                });
              }
            });
          });
        });
        
        // 지도 영역 관찰 시작
        const mapElement = document.getElementById('map');
        if (mapElement) {
          observer.observe(mapElement, {
            childList: true,
            subtree: true
          });
          
          // 5초 후 관찰 중지
          setTimeout(() => {
            observer.disconnect();
          }, 5000);
        }
      }
    </script>
    <!-- 구글 맵 API 스크립트. API 키와 콜백 함수(initMap) 지정 -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDVwJrvIcbqAOX24g9JODhD7DGtTz7z2Pg&callback=initMap" async defer></script>
</body>
</html>