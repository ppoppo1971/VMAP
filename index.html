<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>테스트</title>
    <!-- Kakao Maps JavaScript SDK (지도 렌더링용) -->
    <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=f1268a7e77f3b182e700b92b45d98082&autoload=false&libraries=services"></script>
    
    <script>
      // 파일명에 맞춰 타이틀 자동 설정
      function setTitleFromFilename() {
        const filename = window.location.pathname.split('/').pop().replace('.html', '');
        document.title = filename;
      }
      // 페이지 로드 시 타이틀 설정
      window.addEventListener('load', setTitleFromFilename);
    </script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #map {
            width: 100vw;
            height: 100vh;
            min-height: 100%;
        }
        h1 {
            display: none;
        }
        /* 활성 지도 배지 */
        #activeMapBadge {
            position: absolute;
            top: 10px;
            left: 30px;
            z-index: 15; /* 사이드 패널(z-index:10) 위 */
            background: transparent;
            color: rgba(255, 255, 255, 0.95);
            border-radius: 0;
            padding: 0;
            font-weight: 700;
            font-size: 0.92rem;
            box-shadow: none;
            font-family: 'Noto Sans KR', sans-serif;
        }
        /* 사이드바 스타일 */
        #customMapMenu {
            position: absolute;
            top: 40px;
            left: 30px;
            z-index: 10;
            width: 220px;
            background: #fff;
            border-radius: 16px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.18);
            padding: 12px 9px 9px 9px;
            display: flex;
            flex-direction: column;
            gap: 9px;
            font-family: 'Noto Sans KR', sans-serif;
            transition: box-shadow 0.2s, left 0.3s, opacity 0.3s;
        }
        #customMapMenu.hide {
            left: -260px;
            opacity: 0;
            pointer-events: none;
        }
        #customMapMenu h2 {
            font-size: 1.2rem;
            font-weight: 700;
            margin: 0 0 12px 0;
            color: #222;
        }
        .menu-group {
            margin-bottom: 5px;
        }
        .menu-group label {
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 6px;
            display: block;
            color: #555;
        }
        .menu-group button {
            width: 100%;
            background: #f7f7f7;
            border: none;
            border-radius: 8px;
            padding: 5px 0;
            margin-bottom: 3px;
            font-size: 1rem;
            color: #333;
            cursor: pointer;
            transition: background 0.15s, color 0.15s;
        }
        .menu-group button:hover {
            background: #e0e7ff;
            color: #1d4ed8;
        }
        .menu-group .submenu {
            margin-left: 12px;
            margin-top: 4px;
        }
        .submenu button {
            width: 90%;
            margin-left: 5%;
        }
        /* 사이드 패널 토글 버튼 */
        #menuToggleBtn {
            position: absolute;
            top: 50px;
            left: 18px;
            z-index: 20;
            background: #1d4ed8;
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.3rem;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
            display: none;
            align-items: center;
            justify-content: center;
        }
        #menuToggleBtn.show {
            display: flex;
        }
        #customMapMenu .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.2rem;
            color: #888;
            cursor: pointer;
        }
        .toggle-btn {
            width: 100%;
            background: #f7f7f7;
            border: none;
            border-radius: 8px;
            padding: 5px 0;
            margin-bottom: 3px;
            font-size: 1rem;
            color: #333;
            cursor: pointer;
            text-align: left;
            font-weight: 600;
            transition: background 0.15s, color 0.15s;
        }
        .toggle-btn:hover {
            background: #e0e7ff;
            color: #1d4ed8;
        }
        /* 하위 옵션 들여쓰기 */
        .submenu {
            margin-left: 20px;
        }
        .submenu .submenu {
            margin-left: 20px;
        }
        .submenu button {
            width: 90%;
            margin-left: 0;
        }
        /* 구글맵 하위 옵션 들여쓰기 */
        #googleMapMenu > .toggle-btn {
            margin-left: 20px;
        }
        /* 법정경계 메뉴 스타일 */
        #vworldBoundaryMenu {
            margin-left: 20px;
        }
        #vworldBoundaryMenu button {
            width: 90%;
            margin-left: 0;
        }
        /* 검색 결과 패널 */
        #searchResultsPanel {
            display: none;
            max-height: 320px;
            overflow-y: auto;
            background: #fff;
            border: 1px solid #eee;
            border-radius: 10px;
            padding: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
        }
        .search-results-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
            font-weight: 700;
            color: #222;
        }
        .search-results-close {
            background: none;
            border: none;
            font-size: 1rem;
            color: #888;
            cursor: pointer;
        }
        .search-result-item {
            padding: 8px;
            border-radius: 8px;
            background: #f9fafb;
            margin-bottom: 6px;
            cursor: pointer;
            transition: background 0.15s, color 0.15s;
        }
        .search-result-item:hover {
            background: #e0e7ff;
            color: #1d4ed8;
        }
        .result-title {
            font-weight: 600;
            margin: 0 0 2px 0;
            font-size: 0.95rem;
        }
        .result-sub {
            margin: 0;
            font-size: 0.85rem;
            color: #555;
        }
        /* 50:50 로드뷰 분할 레이아웃 */
        #rvWrapper { position: absolute; top: 0; right: 0; width: 50vw; height: 100vh; z-index: 6; display: none; background: #fff; }
        body.rv-active #rvWrapper { display: block; }
        #roadview { width: 100%; height: 100%; }
        #rvWrapper .rv-close { position: absolute; top: 8px; right: 10px; z-index: 7; background: rgba(0,0,0,0.6); color: #fff; border: none; border-radius: 6px; padding: 4px 8px; cursor: pointer; font-size: 0.9rem; }
    </style>
</head>
<body>
    <h1>테스트</h1>
    <!-- 지도를 표시할 div 요소 -->
    <div id="map"></div>
    <!-- 현재 활성 지도 표시 배지 -->
    <div id="activeMapBadge" aria-live="polite">구글맵 - 일반</div>
    <!-- 사이드 패널 토글 버튼 (패널이 숨겨졌을 때만 보임) -->
    <button id="menuToggleBtn" class="show" onclick="showMenu()" title="메뉴 열기">☰</button>
    <!-- 왼쪽 고정형 사이드바 메뉴 -->
    <div id="customMapMenu" class="hide">
      <button class="close-btn" onclick="hideMenu()" title="닫기">×</button>
      <h2>지도 유형 선택</h2>
      <div class="menu-group">
        <input type="text" id="addressInput" placeholder="장소/주소를 입력하세요" style="width: 98%; margin-bottom: 6px;" onkeydown="if(event.key==='Enter'){searchAddress();}">
        <div id="searchResultsPanel">
          <div class="search-results-header">
            <span>검색 결과</span>
            <button class="search-results-close" onclick="hideSearchResults()">닫기</button>
          </div>
          <div id="searchResultsList"></div>
        </div>
      </div>
      <div class="menu-group">
        <button id="googleMapToggleBtn" class="toggle-btn" onclick="toggleGoogleMapMenu()">+구글맵</button>
        <div id="googleMapMenu" style="display:none; margin-top:8px; margin-left:20px;">
          <button id="roadmapToggleBtn" class="toggle-btn" style="margin-left:0;" onclick="toggleRoadmapMenuAndSetRoadmap()">+일반</button>
          <div id="roadmapMenu" class="submenu" style="display:none;">
            <button onclick="setMapType('terrain')">지형</button>
          </div>
          <button id="satelliteToggleBtn" class="toggle-btn" style="margin-left:0;" onclick="toggleSatelliteMenuAndSetSatellite()">+위성</button>
          <div id="satelliteMenu" class="submenu" style="display:none;">
            <button onclick="setMapType('hybrid')">하이브리드</button>
          </div>
        </div>
      </div>
      <div class="menu-group">
        <button id="vworldToggleBtn" class="toggle-btn" onclick="toggleVworldMenu()">+브이월드</button>
        <div id="vworldMenu" class="submenu" style="display:none;">
          <button onclick="setMapType('브이월드일반')">일반</button>
          <button onclick="setMapType('브이월드영상')">영상</button>
        </div>
      </div>
      <div class="menu-group">
        <button id="kakaoMapToggleBtn" class="toggle-btn" onclick="toggleKakaoMapMenu()">+카카오맵</button>
      <div id="kakaoMapMenu" style="display:none; margin-top:8px; margin-left:20px;">
          <button onclick="loadKakaoMap('normal')">일반</button>
          <button onclick="loadKakaoMap('skyview')">스카이뷰</button>
          <button onclick="toggleRoadview()">로드뷰</button>
        </div>
      </div>
      <div class="menu-group">
        <button id="vworldBoundaryToggleBtn" class="toggle-btn" onclick="toggleVworldBoundaryMenu()">+법정경계</button>
        <div id="vworldBoundaryMenu" class="submenu" style="display:none;">
          <button onclick="loadVworldBoundary('lt_c_adsigg')">시군구</button>
          <button onclick="loadVworldBoundary('lt_c_ademd')">읍면동</button>
          <button onclick="loadVworldBoundary('lt_c_adri')">리</button>
          <button onclick="clearVworldBoundary()">경계제거</button>
        </div>
      </div>
      <div class="menu-group">
        <button id="cadastralToggleBtn" class="toggle-btn" onclick="toggleCadastralOverlay()">연속지적도</button>
      </div>
    </div>
    <div id="kakaoMapContainer" style="display:none; width:100vw; height:100vh; position:absolute; top:0; left:0; z-index:5;">
      <div id="kakaoMapDiv" style="width:100%; height:100%;"></div>
    </div>
    <!-- 50:50 우측 로드뷰 패널 -->
    <div id="rvWrapper">
      <button class="rv-close" onclick="closeRoadviewAll()" title="로드뷰 닫기">×</button>
      <div id="roadview"></div>
    </div>
    <script>
      let map; // 전역 변수로 선언
      // 카카오 REST API를 통한 주소 변환 사용 (브라우저 직접 호출)
      let vworldBoundaryOverlay = null; // 브이월드 경계 오버레이
      let currentBoundaryLayer = null; // 현재 로드된 경계 레이어
      let cadastralOverlay = null;
      let addressMarkers = []; // 주소 검색 마커 배열
      let lastSearchResults = [];
      let lastSearchMode = 'keyword';
      let kakaoMap = null; // 카카오 지도 인스턴스
      let kakaoMarkers = [];
      let kakaoCadastralOverlayEl = null; // 카카오 지적도 오버레이 엘리먼트
      let cadastralOverlayMode = null; // 'google' | 'kakao' | null
      let cadastralUpdateTimer = null; // 구글맵 지적도 갱신 디바운서
      // 지번 경계 폴리곤 (하이라이트)
      let parcelPolygonGoogle = null;
      let parcelPolygonKakao = null;
      // 로드뷰
      let kakaoRoadview = null;
      let kakaoRoadviewClient = null;
      let isRoadviewClickMode = false;
      let roadviewOverlayOn = false;
      let roadviewMarker = null;
      // 카카오맵 우클릭 주소 정보창 관련 변수
      let addressInfoWindow = null;
      let addressInfoMarker = null;
      // 구글맵 우클릭 주소 정보창 관련 변수
      let googleAddressInfoWindow = null;
      let googleAddressInfoMarker = null;
      // 활성 지도 배지 갱신
      function setActiveMapBadge(text) {
        const el = document.getElementById('activeMapBadge');
        if (el) el.textContent = text;
      }
      function updateActiveMapLabel() {
        try {
          if (isKakaoVisible() && kakaoMap) {
            const mt = kakaoMap.getMapTypeId && kakaoMap.getMapTypeId();
            const label = (mt === kakao.maps.MapTypeId.SKYVIEW) ? '카카오맵 - 스카이뷰' : '카카오맵 - 일반';
            setActiveMapBadge(label);
            return;
          }
          
          if (map && map.getMapTypeId) {
            const t = map.getMapTypeId();
            let label = '구글맵 - 일반';
            switch (t) {
              case 'roadmap': label = '구글맵 - 일반'; break;
              case 'terrain': label = '구글맵 - 지형'; break;
              case 'satellite': label = '구글맵 - 위성'; break;
              case 'hybrid': label = '구글맵 - 하이브리드'; break;
              case '브이월드일반': label = '브이월드 - 일반'; break;
              case '브이월드영상': label = '브이월드 - 영상'; break;
            }
            setActiveMapBadge(label);
          }
        } catch (e) { 
          console.log('활성 지도 라벨 업데이트 오류:', e);
        }
      }
      // 구글 줌 <-> 카카오 레벨 변환 유틸리티
      function getGoogleZoom() {
        try {
          if (map && map.getZoom) {
            return map.getZoom();
          }
          return null;
        } catch (e) {
          console.log('구글맵 줌 레벨 가져오기 오류:', e);
          return null;
        }
      }
      function googleZoomToKakaoLevel(googleZoom) {
        if (googleZoom == null) return 5;
        const level = 21 - googleZoom; // 대략적 대응식
        return Math.min(14, Math.max(1, level));
      }
      function kakaoLevelToGoogleZoom(kakaoLevel) {
        if (kakaoLevel == null) return 12;
        const zoom = 21 - kakaoLevel;
        return Math.min(21, Math.max(3, zoom));
      }
      // 구글 맵 초기화 함수
      function initMap() {
        // 서울 시청의 위도, 경도 좌표를 중심으로 설정
        var center = { lat: 37.5665, lng: 126.9780 }; // 서울 시청 좌표
        // 구글 맵 객체 생성 및 옵션 설정
        map = new google.maps.Map(document.getElementById('map'), {
          zoom: 12, // 초기 확대 레벨
          center: center, // 지도 중심 좌표
          mapTypeControl: false, // 기본 가로 지도 타입 메뉴 비활성화
          mapTypeControlOptions: {
            // 지도 타입 선택 컨트롤에 표시할 지도 타입 목록
            mapTypeIds: ['roadmap', 'terrain', 'satellite', 'hybrid', '브이월드일반', '브이월드영상'],
            style: google.maps.MapTypeControlStyle.VERTICAL_BAR, // 세로 메뉴
            position: google.maps.ControlPosition.LEFT_TOP // 원하는 위치
          }
        });
        // REST 방식 사용이므로 별도 초기화 불필요

        // 브이월드 일반 지도(기본 지도) 타일 레이어 정의
        var cadastralMapType = new google.maps.ImageMapType({
          // 각 타일의 URL을 반환하는 함수
          getTileUrl: function(coord, zoom) {
            // 브이월드 일반 지도 타일 서버 URL
            return 'https://xdworld.vworld.kr/2d/Base/service/' + zoom + '/' + coord.x + '/' + coord.y + '.png';
          },
          tileSize: new google.maps.Size(256, 256), // 타일 크기 지정
          name: '브이월드일반', // 지도 타입 이름
          maxZoom: 19 // 최대 확대 레벨
        });

        // 브이월드 영상 지도(위성 지도) 타일 레이어 정의
        var vworldSatelliteMapType = new google.maps.ImageMapType({
          // 각 타일의 URL을 반환하는 함수
          getTileUrl: function(coord, zoom) {
            // 브이월드 영상 지도 타일 서버 URL
            return 'https://xdworld.vworld.kr/2d/Satellite/service/' + zoom + '/' + coord.x + '/' + coord.y + '.jpeg';
          },
          tileSize: new google.maps.Size(256, 256), // 타일 크기 지정
          name: '브이월드영상', // 지도 타입 이름
          maxZoom: 19 // 최대 확대 레벨
        });

        // 사용자 정의 지도 타입(브이월드 일반, 브이월드 영상)을 구글 맵에 추가
        map.mapTypes.set('브이월드일반', cadastralMapType);
        map.mapTypes.set('브이월드영상', vworldSatelliteMapType);
        // 기본 지도 타입을 'roadmap'으로 설정
        map.setMapTypeId('roadmap');
        
        // 지도 이동 이벤트 리스너 추가
        map.addListener('bounds_changed', function() {
          if (currentBoundaryLayer && vworldBoundaryOverlay) {
            // 지도 이동 후 약간의 지연을 두고 경계 업데이트
            setTimeout(() => { updateBoundaryOverlay(); }, 300);
          }
          if (cadastralOverlay) {
            // 구글맵 지적도도 이동/확대에 맞춰 갱신
            if (cadastralUpdateTimer) clearTimeout(cadastralUpdateTimer);
            cadastralUpdateTimer = setTimeout(() => { updateCadastralOverlay(); }, 300);
          }
        });
        // 초기 활성 지도 배지 갱신
        updateActiveMapLabel();
        // 구글맵 우클릭 주소 정보창 리스너 부착
        attachGoogleMapRightClick();
      }
      function setMapType(type) {
        // 카카오맵이 활성화된 상태라면 구글맵으로 전환
        if (isKakaoVisible()) {
          showGoogleMap();
        }
        // 지도 타입 설정
        if (map && map.setMapTypeId) {
          map.setMapTypeId(type);
        }
        updateActiveMapLabel();
      }
      // 구글맵 메뉴 토글
      function toggleGoogleMapMenu() {
        const menu = document.getElementById('googleMapMenu');
        const btn = document.getElementById('googleMapToggleBtn');
        if(menu.style.display === 'none') {
          menu.style.display = 'block';
          btn.textContent = '-구글맵';
        } else {
          menu.style.display = 'none';
          btn.textContent = '+구글맵';
          // 하위 메뉴도 닫기
          document.getElementById('roadmapMenu').style.display = 'none';
          document.getElementById('roadmapToggleBtn').textContent = '+일반';
          document.getElementById('satelliteMenu').style.display = 'none';
          document.getElementById('satelliteToggleBtn').textContent = '+위성';
        }
      }
      // +일반 클릭 시 바로 일반지도를 로드하고, 하위에 지형만 보이도록
      function toggleRoadmapMenuAndSetRoadmap() {
        const menu = document.getElementById('roadmapMenu');
        const btn = document.getElementById('roadmapToggleBtn');
        if(menu.style.display === 'none') {
          setMapType('roadmap');
          menu.style.display = 'block';
          btn.textContent = '-일반';
        } else {
          menu.style.display = 'none';
          btn.textContent = '+일반';
        }
      }
      // +위성 클릭 시 바로 위성지도를 로드하고, 하위에 하이브리드만 보이도록
      function toggleSatelliteMenuAndSetSatellite() {
        const menu = document.getElementById('satelliteMenu');
        const btn = document.getElementById('satelliteToggleBtn');
        if(menu.style.display === 'none') {
          setMapType('satellite');
          menu.style.display = 'block';
          btn.textContent = '-위성';
        } else {
          menu.style.display = 'none';
          btn.textContent = '+위성';
        }
      }
      // 브이월드 메뉴 토글
      function toggleVworldMenu() {
        const menu = document.getElementById('vworldMenu');
        const btn = document.getElementById('vworldToggleBtn');
        if(menu.style.display === 'none') {
          menu.style.display = 'block';
          btn.textContent = '-브이월드';
        } else {
          menu.style.display = 'none';
          btn.textContent = '+브이월드';
        }
      }
      // 카카오맵 메뉴 토글
      function toggleKakaoMapMenu() {
        const menu = document.getElementById('kakaoMapMenu');
        const btn = document.getElementById('kakaoMapToggleBtn');
        if(menu.style.display === 'none') {
          menu.style.display = 'block';
          btn.textContent = '-카카오맵';
        } else {
          menu.style.display = 'none';
          btn.textContent = '+카카오맵';
        }
      }
      function loadKakaoMap(type) {
        const container = document.getElementById('kakaoMapContainer');
        const googleDiv = document.getElementById('map');
        
        if (!container || !googleDiv) {
          console.log('카카오맵 컨테이너 또는 구글맵 div를 찾을 수 없습니다.');
          return;
        }
        
        const wasVisible = container.style.display !== 'none';
        
        // 컨테이너 전환
        googleDiv.style.display = 'none';
        container.style.display = 'block';
        
        // Kakao SDK 비동기 로드 후 지도 생성/업데이트
        if (window.kakao && kakao.maps && kakao.maps.load) {
          kakao.maps.load(function() {
            try {
              // 처음 카카오로 전환되는 순간에만 구글 중심/배율을 강제 동기화
              createOrUpdateKakaoMap(type, !wasVisible);
              updateActiveMapLabel();
              ensureRoadviewInitialized();
              attachOrDetachRoadviewClick();
            } catch (e) {
              console.log('카카오맵 생성/업데이트 오류:', e);
            }
          });
        } else {
          console.log('카카오맵 SDK가 로드되지 않았습니다.');
        }
      }
      function showGoogleMap() {
        const kakaoContainer = document.getElementById('kakaoMapContainer');
        const googleDiv = document.getElementById('map');
        
        if (!googleDiv) return;
        
        // 카카오에서 구글로 전환 시 중심/배율 동기화
        if (kakaoMap && kakaoContainer && kakaoContainer.style.display !== 'none') {
          try {
            const kc = kakaoMap.getCenter();
            const kl = kakaoMap.getLevel();
            const gZoom = kakaoLevelToGoogleZoom(kl);
            if (map && map.setCenter && map.setZoom) {
              map.setCenter({ lat: kc.getLat(), lng: kc.getLng() });
              map.setZoom(gZoom);
            }
          } catch (e) { 
            console.log('카카오맵에서 구글맵으로 전환 시 동기화 오류:', e);
          }
        }
        
        // 컨테이너 전환
        if (kakaoContainer) kakaoContainer.style.display = 'none';
        googleDiv.style.display = 'block';
        
        // 카카오맵 전환 시 정보창 제거
        clearAddressInfoWindow();
        
        // 활성 지도 배지 업데이트
        updateActiveMapLabel();
        
        // 구글로 전환 시 로드뷰 감춤
        hideRoadview();
      }
      function isKakaoVisible() {
        const container = document.getElementById('kakaoMapContainer');
        return container && container.style.display !== 'none';
      }
      function createOrUpdateKakaoMap(type, syncFromGoogle) {
        try {
          const mapTypeId = (type === 'skyview') ? kakao.maps.MapTypeId.SKYVIEW : kakao.maps.MapTypeId.ROADMAP;
          const centerFromGoogle = getCurrentCenter();
          const gZoom = getGoogleZoom();
          const levelFromGoogle = googleZoomToKakaoLevel(gZoom);
          
          if (!kakaoMap) {
            const container = document.getElementById('kakaoMapDiv');
            if (!container) {
              console.log('카카오맵 div를 찾을 수 없습니다.');
              return;
            }
            
            kakaoMap = new kakao.maps.Map(container, {
              center: new kakao.maps.LatLng(centerFromGoogle.lat, centerFromGoogle.lng),
              level: levelFromGoogle,
              mapTypeId: mapTypeId
            });
            
            attachOrDetachRoadviewClick();
            // 우클릭 이벤트 리스너 추가
            attachKakaoMapRightClick();
          } else {
            if (kakaoMap.setMapTypeId) {
              kakaoMap.setMapTypeId(mapTypeId);
            }
            
            if (syncFromGoogle && kakaoMap.setCenter && kakaoMap.setLevel) {
              kakaoMap.setCenter(new kakao.maps.LatLng(centerFromGoogle.lat, centerFromGoogle.lng));
              kakaoMap.setLevel(levelFromGoogle);
            }
          }
          
          // 컨테이너 표시 직후 리레이아웃
          setTimeout(() => { 
            if (kakaoMap && kakaoMap.relayout) {
              kakaoMap.relayout(); 
            }
          }, 0);
          
          // 지적도가 활성 상태였다면 카카오에도 표시
          if (cadastralOverlay || cadastralOverlayMode === 'kakao') {
            loadCadastralOverlayKakao();
          }
          
          // 구글에서 존재하는 마커를 카카오로 동기화
          syncMarkersToKakao();
          updateActiveMapLabel();
          
        } catch (e) {
          console.log('카카오맵 생성/업데이트 중 오류:', e);
        }
      }

      // 로드뷰 초기화/토글/갱신
      function ensureRoadviewInitialized() {
        const rvContainer = document.getElementById('roadview');
        if (!rvContainer) return;
        if (!kakaoRoadviewClient) kakaoRoadviewClient = new kakao.maps.RoadviewClient();
        if (!kakaoRoadview) {
          kakaoRoadview = new kakao.maps.Roadview(rvContainer);
          // 로드뷰 위치 변화 시 지도/마커 동기화
          kakao.maps.event.addListener(kakaoRoadview, 'position_changed', function() {
            try {
              const pos = kakaoRoadview.getPosition();
              if (pos && kakaoMap) {
                updateRoadviewMarkerPosition(pos);
              }
            } catch (e) { /* ignore */ }
          });
        }
      }
      function showRoadviewAtLatLng(lat, lng) {
        ensureRoadviewInitialized();
        if (!kakaoRoadviewClient || !kakaoRoadview) return;
        const position = new kakao.maps.LatLng(lat, lng);
        kakaoRoadviewClient.getNearestPanoId(position, 50, function(panoId) {
          if (!!panoId) {
            document.body.classList.add('rv-active');
            kakaoRoadview.setPanoId(panoId, position);
            updateRoadviewMarkerPosition(position);
          } else {
            alert('해당 위치 주변에 로드뷰가 없습니다.');
          }
        });
      }
      function toggleRoadview() {
        if (!isKakaoVisible()) { alert('카카오맵을 먼저 활성화하세요.'); return; }
        if (!isRoadviewClickMode) { openRoadview(); } else { closeRoadviewAll(); }
      }
      function openRoadview() {
        isRoadviewClickMode = true;
        document.body.classList.add('rv-active');
        toggleRoadviewOverlay(true);
        attachOrDetachRoadviewClick();
      }
      function closeRoadviewAll() {
        isRoadviewClickMode = false;
        document.body.classList.remove('rv-active');
        toggleRoadviewOverlay(false);
        attachOrDetachRoadviewClick();
      }
      
      function hideRoadview() {
        document.body.classList.remove('rv-active');
      }
      function attachOrDetachRoadviewClick() {
        if (!kakaoMap) return;
        // 기존 핸들러 제거 후 필요 시 부착
        kakao.maps.event.removeListener(kakaoMap, 'click', onKakaoMapClickForRoadview);
        if (isKakaoVisible() && isRoadviewClickMode) {
          kakao.maps.event.addListener(kakaoMap, 'click', onKakaoMapClickForRoadview);
        }
      }
      
      // 카카오맵 우클릭 이벤트 리스너 부착
      function attachKakaoMapRightClick() {
        if (!kakaoMap) return;
        kakao.maps.event.addListener(kakaoMap, 'rightclick', onKakaoMapRightClick);
      }
      // 구글맵 우클릭 이벤트 리스너 부착
      function attachGoogleMapRightClick() {
        if (!map || !map.addListener) return;
        map.addListener('rightclick', onGoogleMapRightClick);
      }
      
      // 카카오맵 우클릭 이벤트 핸들러
      function onKakaoMapRightClick(mouseEvent) {
        const latlng = mouseEvent.latLng;
        if (!latlng) return;
        const lat = latlng.getLat();
        const lng = latlng.getLng();
        // 연속지적도 활성 시: 지번 상세 정보 표시, 아니면 기존 주소 정보창
        if (isCadastralOn()) {
          handleParcelInfoAtLatLng(lat, lng);
        } else {
          // 기존 정보창과 마커 제거 후 주소 정보창 표시
          clearAddressInfoWindow();
          addressInfoMarker = new kakao.maps.Marker({ position: latlng, map: kakaoMap });
          searchAddressFromCoordinates(lat, lng);
        }
      }
      // 구글맵 우클릭 이벤트 핸들러
      function onGoogleMapRightClick(mouseEvent) {
        const latlng = mouseEvent && mouseEvent.latLng;
        if (!latlng) return;
        const lat = typeof latlng.lat === 'function' ? latlng.lat() : latlng.lat;
        const lng = typeof latlng.lng === 'function' ? latlng.lng() : latlng.lng;
        // 연속지적도 활성 시: 지번 상세 정보 표시, 아니면 기존 주소 정보창
        if (isCadastralOn()) {
          handleParcelInfoAtLatLng(lat, lng);
        } else {
          clearAddressInfoWindow();
          googleAddressInfoMarker = new google.maps.Marker({ position: latlng, map: map });
          searchAddressFromCoordinates(lat, lng);
        }
      }
      
      // 좌표로 주소 검색
      async function searchAddressFromCoordinates(lat, lng) {
        try {
          const response = await fetch(`https://dapi.kakao.com/v2/local/geo/coord2address.json?x=${lng}&y=${lat}`, {
            headers: { 
              'Authorization': 'KakaoAK c27024d37ac99abf233b12f0efa39099' 
            }
          });
          
          if (!response.ok) throw new Error('HTTP ' + response.status);
          
          const data = await response.json();
          console.log('카카오 API 응답 데이터:', data);
          if (data.documents && data.documents.length > 0) {
            const doc = data.documents[0];
            console.log('주소 문서:', doc);
            console.log('지번명 주소:', doc.address && doc.address.address_name);
            showAddressInfoWindow(lat, lng, doc);
          } else {
            showAddressInfoWindow(lat, lng, null);
          }
        } catch (error) {
          console.log('주소 검색 오류:', error);
          showAddressInfoWindow(lat, lng, null);
        }
      }
      
      // 주소 정보창 표시 (카카오/구글 공용)
      function showAddressInfoWindow(lat, lng, addressDoc) {
        console.log('showAddressInfoWindow 호출됨:', { lat, lng, addressDoc });
        // 기존 정보창 제거
        clearAddressInfoWindow();
        
        // 정보창 내용 생성
        let content = `
          <div style="padding: 10px; min-width: 200px;">
            <div style="font-weight: bold; margin-bottom: 8px; color: #333;">
              🎯 클릭한 위치
            </div>
            <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
              위도: ${lat.toFixed(6)}<br>
              경도: ${lng.toFixed(6)}
            </div>
        `;
        
        if (addressDoc) {
          const jibun = addressDoc.address && addressDoc.address.address_name;
          content += `
            <div style="border-top: 1px solid #eee; padding-top: 8px;">
              <div style="font-weight: bold; color: #1d4ed8; margin-bottom: 4px;">
                📍 지번명 주소
              </div>
              <div style="font-size: 12px; color: #555;">
                ${jibun || '주소 정보 없음'}
              </div>
            </div>
          `;
        } else {
          content += `
            <div style="border-top: 1px solid #eee; padding-top: 8px;">
              <div style="font-size: 12px; color: #999;">
                주소 정보를 찾을 수 없습니다.
              </div>
            </div>
          `;
        }
        
        content += `
          <div style="margin-top: 8px; text-align: center;">
            <button onclick="clearAddressInfoWindow()" style="
              background: #f0f0f0; 
              border: 1px solid #ddd; 
              padding: 4px 8px; 
              border-radius: 4px; 
              font-size: 11px; 
              cursor: pointer;
            ">닫기</button>
          </div>
        </div>
        `;
        // 활성 맵에 맞춰 정보창 생성 및 표시
        if (isKakaoVisible() && kakaoMap) {
          addressInfoWindow = new kakao.maps.InfoWindow({
            content: content,
            position: new kakao.maps.LatLng(lat, lng),
            removable: false
          });
          addressInfoWindow.open(kakaoMap, addressInfoMarker);
        } else if (map) {
          googleAddressInfoWindow = new google.maps.InfoWindow({
            content: content
          });
          if (googleAddressInfoMarker) {
            googleAddressInfoWindow.open(map, googleAddressInfoMarker);
          } else {
            googleAddressInfoWindow.setPosition({ lat, lng });
            googleAddressInfoWindow.open(map);
          }
        }
        // 주소 문서가 있을 때 지번 경계 표시 시도 (좌표로 법정동코드 조회 포함)
        renderParcelBoundaryFromAddress(lat, lng, addressDoc).catch(e => console.log('지번 경계 표시 오류:', e));
      }
      
      // 주소 정보창 제거 (카카오/구글 공용)
      function clearAddressInfoWindow() {
        // 카카오
        if (addressInfoWindow) {
          addressInfoWindow.close();
          addressInfoWindow = null;
        }
        if (addressInfoMarker) {
          addressInfoMarker.setMap(null);
          addressInfoMarker = null;
        }
        // 구글
        if (googleAddressInfoWindow) {
          googleAddressInfoWindow.close();
          googleAddressInfoWindow = null;
        }
        if (googleAddressInfoMarker) {
          googleAddressInfoMarker.setMap(null);
          googleAddressInfoMarker = null;
        }
        // 경계 폴리곤도 함께 제거
        clearParcelPolygons();
      }

      // ===== 지번 경계 표시 로직 =====
      function isCadastralOn() {
        return !!(cadastralOverlay || cadastralOverlayMode === 'kakao');
      }
      function buildPnuFromKakaoAddress(address) {
        if (!address) return null;
        const bCode = (address.b_code || '').trim(); // 10자리 법정동코드 (없을 수 있음)
        if (!bCode || bCode.length !== 10) return null;
        const isMountain = (address.mountain_yn || address.mountainYn || 'N').toUpperCase() === 'Y' ? '1' : '0';
        const mainNoRaw = String(address.main_address_no || address.mainAddressNo || '0');
        const subNoRaw = String(address.sub_address_no || address.subAddressNo || '0');
        const mainNo = mainNoRaw.padStart(4, '0');
        const subNo = subNoRaw.padStart(4, '0');
        return `${bCode}${isMountain}${mainNo}${subNo}`; // 19자리 PNU
      }

      async function fetchParcelGeometryByPnu(pnu) {
        const key = '910896AA-BE88-363C-B54B-9FB421BD05DB';
        const base = 'https://api.vworld.kr/ned/wfs/getCtnlgsSpceWFS';
        const params = new URLSearchParams();
        params.set('key', key);
        // 브라우저에서 도메인 요구될 수 있음. file:// 실행 시 공백이므로 제외
        const host = (location.protocol.startsWith('http') ? location.hostname : '');
        if (host) params.set('domain', host);
        params.set('typename', 'dt_d002');
        params.set('pnu', pnu);
        params.set('srsName', 'EPSG:4326');
        params.set('output', 'application/json');
        const url = `${base}?${params.toString()}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error('WFS HTTP ' + res.status);
        const data = await res.json();
        const features = (data && (data.features || (data.featureCollection && data.featureCollection.features))) || [];
        if (!features.length) return null;
        return features[0].geometry || null; // GeoJSON geometry
      }

      async function fetchParcelsByBbox(bboxStr) {
        const key = '910896AA-BE88-363C-B54B-9FB421BD05DB';
        const base = 'https://api.vworld.kr/ned/wfs/getCtnlgsSpceWFS';
        const params = new URLSearchParams();
        params.set('key', key);
        const host = (location.protocol.startsWith('http') ? location.hostname : '');
        if (host) params.set('domain', host);
        params.set('typename', 'dt_d002');
        params.set('bbox', bboxStr);
        params.set('srsName', 'EPSG:4326');
        params.set('output', 'application/json');
        const url = `${base}?${params.toString()}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error('WFS HTTP ' + res.status);
        const data = await res.json();
        return (data && data.features) || [];
      }

      function clearParcelPolygons() {
        try {
          if (parcelPolygonGoogle) {
            parcelPolygonGoogle.setMap(null);
            parcelPolygonGoogle = null;
          }
        } catch (_) {}
        try {
          if (parcelPolygonKakao) {
            parcelPolygonKakao.setMap && parcelPolygonKakao.setMap(null);
            parcelPolygonKakao = null;
          }
        } catch (_) {}
      }

      async function fetchBcodeByCoord(lat, lng) {
        const url = `https://dapi.kakao.com/v2/local/geo/coord2regioncode.json?x=${lng}&y=${lat}`;
        const res = await fetch(url, { headers: { 'Authorization': 'KakaoAK c27024d37ac99abf233b12f0efa39099' } });
        if (!res.ok) throw new Error('coord2regioncode HTTP ' + res.status);
        const data = await res.json();
        const docs = Array.isArray(data && data.documents) ? data.documents : [];
        // region_type==='B' 우선, 없으면 첫 10자리 코드
        const bDoc = docs.find(d => d.region_type === 'B') || docs.find(d => (d.code || '').length === 10);
        return bDoc ? String(bDoc.code).slice(0, 10) : null;
      }

      async function renderParcelBoundaryFromAddress(lat, lng, addressDoc) {
        if (!addressDoc || !addressDoc.address) return;
        const address = { ...addressDoc.address };
        if (!address.b_code) {
          try {
            const bcode = await fetchBcodeByCoord(lat, lng);
            if (bcode) address.b_code = bcode;
          } catch (e) {
            console.log('b_code 조회 실패:', e);
          }
        }
        const pnu = buildPnuFromKakaoAddress(address);
        if (!pnu) return;
        const geometry = await fetchParcelGeometryByPnu(pnu);
        if (!geometry) return;
        if (isKakaoVisible() && kakaoMap) {
          drawParcelPolygonKakao(geometry);
        } else if (map) {
          drawParcelPolygonGoogle(geometry);
        }
      }

      function drawParcelPolygonGoogle(geometry) {
        // geometry: GeoJSON (Polygon | MultiPolygon) with [lng,lat]
        try { if (parcelPolygonGoogle) { parcelPolygonGoogle.setMap(null); } } catch (_) {}
        const paths = [];
        if (geometry.type === 'Polygon') {
          geometry.coordinates.forEach(ring => {
            paths.push(ring.map(([lng, lat]) => ({ lat, lng })));
          });
        } else if (geometry.type === 'MultiPolygon') {
          geometry.coordinates.forEach(polygon => {
            polygon.forEach(ring => {
              paths.push(ring.map(([lng, lat]) => ({ lat, lng })));
            });
          });
        } else {
          return;
        }
        parcelPolygonGoogle = new google.maps.Polygon({
          paths,
          strokeColor: '#ff3b30',
          strokeOpacity: 1.0,
          strokeWeight: 2,
          fillColor: '#ff3b30',
          fillOpacity: 0.15,
          clickable: false,
          geodesic: false
        });
        parcelPolygonGoogle.setMap(map);
      }

      function drawParcelPolygonKakao(geometry) {
        try { if (parcelPolygonKakao) { parcelPolygonKakao.setMap && parcelPolygonKakao.setMap(null); } } catch (_) {}
        const paths = [];
        if (geometry.type === 'Polygon') {
          geometry.coordinates.forEach(ring => {
            paths.push(ring.map(([lng, lat]) => new kakao.maps.LatLng(lat, lng)));
          });
        } else if (geometry.type === 'MultiPolygon') {
          geometry.coordinates.forEach(polygon => {
            polygon.forEach(ring => {
              paths.push(ring.map(([lng, lat]) => new kakao.maps.LatLng(lat, lng)));
            });
          });
        } else {
          return;
        }
        parcelPolygonKakao = new kakao.maps.Polygon({
          path: paths,
          strokeWeight: 2,
          strokeColor: '#ff3b30',
          strokeOpacity: 1,
          fillColor: '#ff3b30',
          fillOpacity: 0.15
        });
        parcelPolygonKakao.setMap(kakaoMap);
      }

      // 지적도 ON 상태에서 우클릭 시 해당 위치의 지번 상세 정보 표시
      async function handleParcelInfoAtLatLng(lat, lng) {
        try {
          // 작은 bbox 구성 (ymin,xmin,ymax,xmax,EPSG:4326)
          const dy = 0.0006, dx = 0.0006;
          const bbox = `${(lat - dy)},${(lng - dx)},${(lat + dy)},${(lng + dx)},EPSG:4326`;
          const features = await fetchParcelsByBbox(bbox);
          if (!features || features.length === 0) {
            alert('해당 위치의 지번 정보를 찾을 수 없습니다.');
            return;
          }
          const picked = pickFeatureContainingPoint(features, lat, lng) || features[0];
          if (picked && picked.geometry) {
            if (isKakaoVisible() && kakaoMap) {
              drawParcelPolygonKakao(picked.geometry);
            } else if (map) {
              drawParcelPolygonGoogle(picked.geometry);
            }
          }
          showParcelInfoWindow(lat, lng, picked && picked.properties ? picked.properties : {});
        } catch (e) {
          console.log('parcel info error:', e);
          alert('지번 정보를 불러오는 중 오류가 발생했습니다.');
        }
      }

      function pickFeatureContainingPoint(features, lat, lng) {
        const pt = { lat, lng };
        for (let i = 0; i < features.length; i++) {
          const g = features[i] && features[i].geometry;
          if (!g) continue;
          if (g.type === 'Polygon') {
            if (polygonContainsPoint(g.coordinates, pt)) return features[i];
          } else if (g.type === 'MultiPolygon') {
            for (let j = 0; j < g.coordinates.length; j++) {
              if (polygonContainsPoint(g.coordinates[j], pt)) return features[i];
            }
          }
        }
        return null;
      }

      // rings: [ [ [lng,lat], ... ] , ... ]
      function polygonContainsPoint(rings, point) {
        if (!Array.isArray(rings) || rings.length === 0) return false;
        const outer = rings[0];
        return pointInRing(outer, point);
      }

      function pointInRing(ring, point) {
        let inside = false;
        for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
          const xi = ring[i][0], yi = ring[i][1];
          const xj = ring[j][0], yj = ring[j][1];
          const intersect = ((yi > point.lat) !== (yj > point.lat)) &&
            (point.lng < (xj - xi) * (point.lat - yi) / ((yj - yi) || 1e-12) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function showParcelInfoWindow(lat, lng, props) {
        clearAddressInfoWindow();
        const pnu = props.pnu || '';
        const jibunText = props.lnm_lndcgr_smbol || '';
        const mnnm = props.mnnm || '';
        const slno = props.slno || '';
        const content = `
          <div style="padding:10px; min-width:220px;">
            <div style="font-weight:700; margin-bottom:6px; color:#333;">지번 상세 정보</div>
            <div style="font-size:12px; color:#666; margin-bottom:6px;">위도: ${lat.toFixed(6)} / 경도: ${lng.toFixed(6)}</div>
            <div style="font-size:12px; color:#555;">
              <div><b>지번</b>: ${jibunText || (mnnm ? `${mnnm}${slno?('-'+slno):''}` : '(알 수 없음)')}</div>
              <div><b>PNU</b>: ${pnu || '(없음)'}</div>
            </div>
            <div style="margin-top:8px; text-align:center;">
              <button onclick="clearAddressInfoWindow()" style="background:#f0f0f0; border:1px solid #ddd; padding:4px 8px; border-radius:4px; font-size:11px; cursor:pointer;">닫기</button>
            </div>
          </div>
        `;
        if (isKakaoVisible() && kakaoMap) {
          addressInfoMarker = new kakao.maps.Marker({ position: new kakao.maps.LatLng(lat, lng), map: kakaoMap });
          addressInfoWindow = new kakao.maps.InfoWindow({ content, position: new kakao.maps.LatLng(lat, lng), removable: false });
          addressInfoWindow.open(kakaoMap, addressInfoMarker);
        } else if (map) {
          googleAddressInfoMarker = new google.maps.Marker({ position: { lat, lng }, map });
          googleAddressInfoWindow = new google.maps.InfoWindow({ content });
          googleAddressInfoWindow.open(map, googleAddressInfoMarker);
        }
      }
      function onKakaoMapClickForRoadview(mouseEvent) {
        const latlng = mouseEvent.latLng;
        if (!latlng) return;
        showRoadviewAtLatLng(latlng.getLat(), latlng.getLng());
      }

      // 지도 위 로드뷰 오버레이/마커
      function toggleRoadviewOverlay(active) {
        if (!kakaoMap) return;
        if (active) {
          if (!roadviewOverlayOn) {
            kakaoMap.addOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
            roadviewOverlayOn = true;
          }
          // 마커 준비
          if (!roadviewMarker) {
            const markImage = new kakao.maps.MarkerImage(
              'https://t1.daumcdn.net/localimg/localimages/07/2018/pc/roadview_minimap_wk_2018.png',
              new kakao.maps.Size(26, 46),
              {
                spriteSize: new kakao.maps.Size(1666, 168),
                spriteOrigin: new kakao.maps.Point(705, 114),
                offset: new kakao.maps.Point(13, 46)
              }
            );
            roadviewMarker = new kakao.maps.Marker({ image: markImage, draggable: true });
            kakao.maps.event.addListener(roadviewMarker, 'dragend', function() {
              const pos = roadviewMarker.getPosition();
              if (pos) showRoadviewAtLatLng(pos.getLat(), pos.getLng());
            });
          }
          if (roadviewMarker && !roadviewMarker.getMap()) {
            roadviewMarker.setMap(kakaoMap);
            roadviewMarker.setPosition(kakaoMap.getCenter());
          }
        } else {
          if (roadviewOverlayOn) {
            kakaoMap.removeOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
            roadviewOverlayOn = false;
          }
          if (roadviewMarker) roadviewMarker.setMap(null);
          hideRoadview();
        }
      }
      function updateRoadviewMarkerPosition(latlng) {
        if (!kakaoMap) return;
        if (roadviewMarker && roadviewOverlayOn) {
          roadviewMarker.setMap(kakaoMap);
          roadviewMarker.setPosition(latlng);
        }
      }
      function syncMarkersToKakao() {
        try {
          if (!kakaoMap) return;
          
          // 기존 카카오 마커 제거
          if (kakaoMarkers && kakaoMarkers.length) {
            kakaoMarkers.forEach(m => {
              try {
                if (m && m.setMap) m.setMap(null);
              } catch (e) { /* ignore individual marker errors */ }
            });
            kakaoMarkers = [];
          }
          
          // 구글 마커를 카카오 마커로 복제
          if (addressMarkers && addressMarkers.length) {
            addressMarkers.forEach(gm => {
              try {
                if (!gm || !gm.getPosition) return;
                
                const pos = gm.getPosition();
                if (!pos) return;
                
                const lat = typeof pos.lat === 'function' ? pos.lat() : (pos.lat || null);
                const lng = typeof pos.lng === 'function' ? pos.lng() : (pos.lng || null);
                
                if (lat == null || lng == null) return;
                
                const marker = new kakao.maps.Marker({
                  position: new kakao.maps.LatLng(lat, lng),
                  map: kakaoMap
                });
                
                kakao.maps.event.addListener(marker, 'click', function() { 
                  removeSpecificKakaoMarker(marker); 
                });
                
                kakaoMarkers.push(marker);
              } catch (e) { 
                console.log('개별 마커 동기화 오류:', e);
              }
            });
          }
        } catch (e) {
          console.log('마커 동기화 중 오류:', e);
        }
      }
      function getCurrentCenter() {
        let centerLat = 37.5665;
        let centerLng = 126.9780;
        
        try {
          if (map && map.getCenter) {
            const c = map.getCenter();
            if (c) {
              centerLat = (typeof c.lat === 'function') ? c.lat() : c.lat;
              centerLng = (typeof c.lng === 'function') ? c.lng() : c.lng;
            }
          }
        } catch (e) {
          console.log('구글맵 중심점 가져오기 오류:', e);
        }
        
        return { lat: centerLat, lng: centerLng };
      }
      async function searchAddress() {
        const query = document.getElementById('addressInput').value;
        if (!query) {
          alert('검색어를 입력하세요.');
          return;
        }

        try {
          // 1) 장소(키워드) 검색을 우선 시도
          let centerLng = null;
          let centerLat = null;
          if (map && map.getCenter) {
            const c = map.getCenter();
            if (c) {
              centerLat = typeof c.lat === 'function' ? c.lat() : c.lat;
              centerLng = typeof c.lng === 'function' ? c.lng() : c.lng;
            }
          }

          const keywordParams = new URLSearchParams({ query, size: '15' });
          if (centerLng != null && centerLat != null) {
            keywordParams.set('x', String(centerLng));
            keywordParams.set('y', String(centerLat));
            keywordParams.set('radius', '20000'); // 20km 우선
          }
          const keywordUrl = 'https://dapi.kakao.com/v2/local/search/keyword.json?' + keywordParams.toString();
          let res = await fetch(keywordUrl, {
            headers: { Authorization: 'KakaoAK c27024d37ac99abf233b12f0efa39099' }
          });
          if (!res.ok) throw new Error('HTTP ' + res.status + ' (keyword)');
          let data = await res.json();
          let documents = Array.isArray(data && data.documents) ? data.documents : [];
          let usedMode = 'keyword';

          // 2) 키워드 결과가 없으면 지도 위치 제약 없이 전국 검색 재시도
          if (documents.length === 0) {
            const globalKeywordUrl = 'https://dapi.kakao.com/v2/local/search/keyword.json?query=' + encodeURIComponent(query) + '&size=15';
            res = await fetch(globalKeywordUrl, {
              headers: { Authorization: 'KakaoAK c27024d37ac99abf233b12f0efa39099' }
            });
            if (!res.ok) throw new Error('HTTP ' + res.status + ' (keyword-global)');
            data = await res.json();
            documents = Array.isArray(data && data.documents) ? data.documents : [];
          }

          // 3) 그래도 없으면 주소 검색으로 폴백
          if (documents.length === 0) {
            const addressUrl = 'https://dapi.kakao.com/v2/local/search/address.json?query=' + encodeURIComponent(query);
            res = await fetch(addressUrl, {
              headers: { Authorization: 'KakaoAK c27024d37ac99abf233b12f0efa39099' }
            });
            if (!res.ok) throw new Error('HTTP ' + res.status + ' (address)');
            data = await res.json();
            documents = Array.isArray(data && data.documents) ? data.documents : [];
            usedMode = 'address';
          }

          if (!documents || documents.length === 0) {
            alert('검색 결과가 없습니다.');
            return;
          }

          // 3) 결과 목록을 패널에 렌더링하고 사용자 선택을 기다림
          showSearchResults(documents, usedMode);
        } catch (e) {
          alert('검색 중 오류가 발생했습니다: ' + e.message);
        }
      }

      function showSearchResults(documents, mode) {
        lastSearchResults = documents.slice(0, 20);
        lastSearchMode = mode;
        const list = document.getElementById('searchResultsList');
        if (!list) return;
        list.innerHTML = '';
        lastSearchResults.forEach((doc, idx) => {
          const item = document.createElement('div');
          item.className = 'search-result-item';
          item.dataset.index = String(idx);
          const title = mode === 'keyword' ? (doc.place_name || '') : (doc.address_name || '');
          const sub = mode === 'keyword' ? (doc.road_address_name || doc.address_name || '') : ((doc.road_address && doc.road_address.address_name) || '');
          item.innerHTML = `
            <p class="result-title">${idx + 1}. ${title || '(이름 없음)'}</p>
            <p class="result-sub">${sub}</p>
          `;
          item.addEventListener('click', () => selectSearchResult(idx));
          list.appendChild(item);
        });
        const panel = document.getElementById('searchResultsPanel');
        if (panel) panel.style.display = 'block';
      }

      function hideSearchResults() {
        const panel = document.getElementById('searchResultsPanel');
        if (panel) panel.style.display = 'none';
        const list = document.getElementById('searchResultsList');
        if (list) list.innerHTML = '';
        lastSearchResults = [];
      }

      function selectSearchResult(index) {
        const doc = lastSearchResults[index];
        if (!doc) return;
        const lat = parseFloat(doc.y);
        const lng = parseFloat(doc.x);
        if (isNaN(lat) || isNaN(lng)) return;
        const position = { lat, lng };

        const title = lastSearchMode === 'keyword' ? (doc.place_name || '') : (doc.address_name || '');

        if (isKakaoVisible() && kakaoMap) {
          kakaoMap.setCenter(new kakao.maps.LatLng(position.lat, position.lng));
          // 구글 줌 16과 유사한 카카오 레벨로 설정
          kakaoMap.setLevel(googleZoomToKakaoLevel(16));
          const marker = new kakao.maps.Marker({
            position: new kakao.maps.LatLng(position.lat, position.lng),
            map: kakaoMap,
            title
          });
          kakao.maps.event.addListener(marker, 'click', function() { removeSpecificKakaoMarker(marker); });
          kakaoMarkers.push(marker);
        } else {
          map.setCenter(position);
          map.setZoom(16);
          const newMarker = new google.maps.Marker({
            position,
            map,
            title,
            animation: google.maps.Animation.DROP
          });
          newMarker.addListener('click', function () { removeSpecificMarker(newMarker); });
          addressMarkers.push(newMarker);
        }

        hideSearchResults();
      }
      
      // 특정 마커 제거 함수
      function removeSpecificMarker(marker) {
        if (marker) {
          marker.setMap(null);
          // 배열에서 해당 마커 제거
          const index = addressMarkers.indexOf(marker);
          if (index > -1) {
            addressMarkers.splice(index, 1);
          }
        }
      }
      function removeSpecificKakaoMarker(marker) {
        if (marker) {
          marker.setMap && marker.setMap(null);
          const idx = kakaoMarkers.indexOf(marker);
          if (idx > -1) kakaoMarkers.splice(idx, 1);
        }
      }
      
      // 모든 주소 마커 제거 함수
      function clearAllAddressMarkers() {
        addressMarkers.forEach(marker => {
          marker.setMap(null);
        });
        addressMarkers = [];
        if (kakaoMarkers && kakaoMarkers.length) {
          kakaoMarkers.forEach(m => m.setMap && m.setMap(null));
          kakaoMarkers = [];
        }
        document.getElementById('addressInput').value = '';
      }
      // 사이드 패널 토글 함수
      function hideMenu() {
        document.getElementById('customMapMenu').classList.add('hide');
        document.getElementById('menuToggleBtn').classList.add('show');
      }
      function showMenu() {
        document.getElementById('customMapMenu').classList.remove('hide');
        document.getElementById('menuToggleBtn').classList.remove('show');
      }
      
      // 브이월드 경계 메뉴 토글
      function toggleVworldBoundaryMenu() {
        const menu = document.getElementById('vworldBoundaryMenu');
        const btn = document.getElementById('vworldBoundaryToggleBtn');
        if(menu.style.display === 'none') {
          menu.style.display = 'block';
          btn.textContent = '-법정경계';
        } else {
          menu.style.display = 'none';
          btn.textContent = '+법정경계';
        }
      }
      
      // 브이월드 경계 로드 함수
      function loadVworldBoundary(layerType) {
        if (!map) {
          alert('지도가 아직 준비되지 않았습니다.');
          return;
        }
        
        // 현재 지도 zoom 값 확인
        const zoom = map.getZoom();
        // 기존 최대 허용 zoom은 16(예시)로 가정, 두 배로 32로 설정
        const MAX_BOUNDARY_ZOOM = 32;
        if (zoom > MAX_BOUNDARY_ZOOM) {
          alert('이 경계는 더 이상 확대할 수 없습니다. (최대 허용 zoom: ' + MAX_BOUNDARY_ZOOM + ')');
          return;
        }
        
        showGoogleMap();
        clearVworldBoundary();
        
        const bounds = map.getBounds();
        if (!bounds) {
          alert('지도 영역을 확정할 수 없습니다. 지도를 이동한 후 다시 시도해주세요.');
          return;
        }
        
        const ne = bounds.getNorthEast();
        const sw = bounds.getSouthWest();
        
        // EPSG:4326의 경우 (ymin,xmin,ymax,xmax) 형식
        const bbox = `${sw.lat()},${sw.lng()},${ne.lat()},${ne.lng()}`;
        
        // map div의 실제 크기 사용
        const mapDiv = document.getElementById('map');
        const width = mapDiv.offsetWidth;
        const height = mapDiv.offsetHeight;
        
        // 브이월드 공식 WMS API URL 생성
        const apiUrl = 'https://api.vworld.kr/req/wms';
        const params = new URLSearchParams({
          key: '910896AA-BE88-363C-B54B-9FB421BD05DB', // 본인 키로 교체
          service: 'WMS',
          request: 'GetMap',
          version: '1.3.0',
          layers: layerType, // 공식 WMS명
          styles: '', // 필요시 스타일명 입력
          crs: 'EPSG:4326',
          bbox: bbox,
          width: width,
          height: height,
          format: 'image/png',
          transparent: 'true',
          exceptions: 'text/xml'
        });
        const fullUrl = `${apiUrl}?${params.toString()}`;

        // 이미지 오버레이 생성
        const imageBounds = new google.maps.LatLngBounds(
          new google.maps.LatLng(sw.lat(), sw.lng()),
          new google.maps.LatLng(ne.lat(), ne.lng())
        );

        vworldBoundaryOverlay = new google.maps.GroundOverlay(fullUrl, imageBounds, {
          opacity: 0.8
        });

        vworldBoundaryOverlay.setMap(map);
        currentBoundaryLayer = layerType;

        // 메뉴 상태 업데이트
        updateBoundaryMenuState(layerType);
      }
      
      // 브이월드 경계 제거 함수
      function clearVworldBoundary() {
        if (vworldBoundaryOverlay) {
          vworldBoundaryOverlay.setMap(null);
          vworldBoundaryOverlay = null;
        }
        currentBoundaryLayer = null;
        updateBoundaryMenuState(null);
      }
      
      // 경계 메뉴 상태 업데이트
      function updateBoundaryMenuState(activeLayer) {
        const buttons = document.querySelectorAll('#vworldBoundaryMenu button');
        buttons.forEach(btn => {
          btn.style.background = '#f7f7f7';
          btn.style.color = '#333';
        });
        
        if (activeLayer) {
          const activeBtn = document.querySelector(`#vworldBoundaryMenu button[onclick*="${activeLayer}"]`);
          if (activeBtn) {
            activeBtn.style.background = '#e0e7ff';
            activeBtn.style.color = '#1d4ed8';
          }
        }
      }
      
      // 경계 오버레이 업데이트 함수
      function updateBoundaryOverlay() {
        if (!currentBoundaryLayer || !map) return;
        
        // 현재 지도 zoom 값 확인
        const zoom = map.getZoom();
        const MAX_BOUNDARY_ZOOM = 32;
        if (zoom > MAX_BOUNDARY_ZOOM) {
          clearVworldBoundary();
          alert('이 경계는 더 이상 확대할 수 없습니다. (최대 허용 zoom: ' + MAX_BOUNDARY_ZOOM + ')');
          return;
        }
        
        const bounds = map.getBounds();
        if (!bounds) return;
        
        const ne = bounds.getNorthEast();
        const sw = bounds.getSouthWest();
        
        // EPSG:4326의 경우 (ymin,xmin,ymax,xmax) 형식
        const bbox = `${sw.lat()},${sw.lng()},${ne.lat()},${ne.lng()}`;
        
        // map div의 실제 크기 사용
        const mapDiv = document.getElementById('map');
        const width = mapDiv.offsetWidth;
        const height = mapDiv.offsetHeight;
        
        // 브이월드 공식 WMS API URL 생성
        const apiUrl = 'https://api.vworld.kr/req/wms';
        const params = new URLSearchParams({
          key: '910896AA-BE88-363C-B54B-9FB421BD05DB',
          service: 'WMS',
          request: 'GetMap',
          version: '1.3.0',
          layers: currentBoundaryLayer,
          styles: '',
          crs: 'EPSG:4326',
          bbox: bbox,
          width: width,
          height: height,
          format: 'image/png',
          transparent: 'true',
          exceptions: 'text/xml'
        });
        const fullUrl = `${apiUrl}?${params.toString()}`;

        // 기존 오버레이 제거
        if (vworldBoundaryOverlay) {
          vworldBoundaryOverlay.setMap(null);
        }

        // 새로운 이미지 오버레이 생성
        const imageBounds = new google.maps.LatLngBounds(
          new google.maps.LatLng(sw.lat(), sw.lng()),
          new google.maps.LatLng(ne.lat(), ne.lng())
        );

        vworldBoundaryOverlay = new google.maps.GroundOverlay(fullUrl, imageBounds, {
          opacity: 0.8
        });

        vworldBoundaryOverlay.setMap(map);
      }
      function loadCadastralOverlay() {
        // 카카오맵이 보이는 경우 카카오 방식으로 로드
        if (isKakaoVisible()) {
          loadCadastralOverlayKakao();
          return;
        }
        if (!map) {
          alert('지도가 아직 준비되지 않았습니다.');
          return;
        }
        const zoom = map.getZoom();
        const MAX_CADASTRAL_ZOOM = 32;
        if (zoom > MAX_CADASTRAL_ZOOM) {
          alert('이 지적도는 더 이상 확대할 수 없습니다. (최대 허용 zoom: ' + MAX_CADASTRAL_ZOOM + ')');
          return;
        }
        clearCadastralOverlay();
        const bounds = map.getBounds();
        if (!bounds) {
          alert('지도 영역을 확정할 수 없습니다. 지도를 이동한 후 다시 시도해주세요.');
          return;
        }
        const ne = bounds.getNorthEast();
        const sw = bounds.getSouthWest();
        const bbox = `${sw.lat()},${sw.lng()},${ne.lat()},${ne.lng()}`;
        const mapDiv = document.getElementById('map');
        const width = mapDiv.offsetWidth;
        const height = mapDiv.offsetHeight;
        const apiUrl = 'https://api.vworld.kr/req/wms';
        const params = new URLSearchParams({
          key: '910896AA-BE88-363C-B54B-9FB421BD05DB',
          service: 'WMS',
          request: 'GetMap',
          version: '1.3.0',
          layers: 'lp_pa_cbnd_bonbun,lp_pa_cbnd_bubun',
          styles: '',
          crs: 'EPSG:4326',
          bbox: bbox,
          width: width,
          height: height,
          format: 'image/png',
          transparent: 'true',
          exceptions: 'text/xml'
        });
        const fullUrl = `${apiUrl}?${params.toString()}`;
        const imageBounds = new google.maps.LatLngBounds(
          new google.maps.LatLng(sw.lat(), sw.lng()),
          new google.maps.LatLng(ne.lat(), ne.lng())
        );
        cadastralOverlay = new google.maps.GroundOverlay(fullUrl, imageBounds, {
          opacity: 0.8
        });
        cadastralOverlay.setMap(map);
        
        // 버튼 상태 유지
        updateCadastralButtonState(true);
        
        // 버튼 상태 업데이트
        updateCadastralButtonState(true);
      }
      function clearCadastralOverlay() {
        // 카카오 지적도 제거 우선 처리
        if (kakaoCadastralOverlayEl) {
          clearCadastralOverlayKakao();
        }
        if (cadastralOverlay) {
          cadastralOverlay.setMap(null);
          cadastralOverlay = null;
        }
        // 버튼 상태 업데이트
        updateCadastralButtonState(false);
      }
      
      // 연속지적도 토글 함수
      function toggleCadastralOverlay() {
        if (isKakaoVisible()) {
          // 카카오맵 표시 상태
          if (kakaoCadastralOverlayEl) {
            clearCadastralOverlayKakao();
          } else {
            loadCadastralOverlayKakao();
          }
        } else {
          // 구글맵 표시 상태
          if (cadastralOverlay) {
            clearCadastralOverlay();
          } else {
            loadCadastralOverlay();
          }
        }
      }
      
      // 연속지적도 버튼 상태 업데이트 함수
      function updateCadastralButtonState(isLoaded) {
        const btn = document.getElementById('cadastralToggleBtn');
        if (isLoaded) {
          btn.textContent = '-지적도제거';
          btn.style.background = '#e0e7ff';
          btn.style.color = '#1d4ed8';
        } else {
          btn.textContent = '+연속지적도';
          btn.style.background = '#f7f7f7';
          btn.style.color = '#333';
        }
      }
      // 지도 이동 시 연속지적도 오버레이도 갱신
      map && map.addListener && map.addListener('bounds_changed', function() {
        if (cadastralOverlay) {
          setTimeout(() => {
            updateCadastralOverlay();
          }, 500);
        }
      });
      function updateCadastralOverlay() {
        // 카카오 지적도 모드
        if (cadastralOverlayMode === 'kakao') {
          updateCadastralOverlayKakao();
          return;
        }
        if (!map || !cadastralOverlay) return;
        const zoom = map.getZoom();
        const MAX_CADASTRAL_ZOOM = 32;
        if (zoom > MAX_CADASTRAL_ZOOM) {
          clearCadastralOverlay();
          alert('이 지적도는 더 이상 확대할 수 없습니다. (최대 허용 zoom: ' + MAX_CADASTRAL_ZOOM + ')');
          return;
        }
        const bounds = map.getBounds();
        if (!bounds) return;
        const ne = bounds.getNorthEast();
        const sw = bounds.getSouthWest();
        const bbox = `${sw.lat()},${sw.lng()},${ne.lat()},${ne.lng()}`;
        const mapDiv = document.getElementById('map');
        const width = mapDiv.offsetWidth;
        const height = mapDiv.offsetHeight;
        const apiUrl = 'https://api.vworld.kr/req/wms';
        const params = new URLSearchParams({
          key: '910896AA-BE88-363C-B54B-9FB421BD05DB',
          service: 'WMS',
          request: 'GetMap',
          version: '1.3.0',
          layers: 'lp_pa_cbnd_bonbun,lp_pa_cbnd_bubun',
          styles: '',
          crs: 'EPSG:4326',
          bbox: bbox,
          width: width,
          height: height,
          format: 'image/png',
          transparent: 'true',
          exceptions: 'text/xml'
        });
        const fullUrl = `${apiUrl}?${params.toString()}`;
        if (cadastralOverlay) {
          cadastralOverlay.setMap(null);
        }
        const imageBounds = new google.maps.LatLngBounds(
          new google.maps.LatLng(sw.lat(), sw.lng()),
          new google.maps.LatLng(ne.lat(), ne.lng())
        );
        cadastralOverlay = new google.maps.GroundOverlay(fullUrl, imageBounds, {
          opacity: 0.8
        });
        cadastralOverlay.setMap(map);
      }
      // 카카오 지적도 로드/업데이트/제거
      function loadCadastralOverlayKakao() {
        if (!kakaoMap) { alert('카카오맵이 아직 준비되지 않았습니다.'); return; }
        const mapDiv = document.getElementById('kakaoMapDiv');
        if (!mapDiv) return;
        const bounds = kakaoMap.getBounds();
        if (!bounds) return;
        const sw = bounds.getSouthWest();
        const ne = bounds.getNorthEast();
        const bbox = `${sw.getLat()},${sw.getLng()},${ne.getLat()},${ne.getLng()}`;
        const width = mapDiv.offsetWidth;
        const height = mapDiv.offsetHeight;
        const apiUrl = 'https://api.vworld.kr/req/wms';
        const params = new URLSearchParams({
          key: '910896AA-BE88-363C-B54B-9FB421BD05DB',
          service: 'WMS',
          request: 'GetMap',
          version: '1.3.0',
          layers: 'lp_pa_cbnd_bonbun,lp_pa_cbnd_bubun',
          styles: '',
          crs: 'EPSG:4326',
          bbox: bbox,
          width: String(width),
          height: String(height),
          format: 'image/png',
          transparent: 'true',
          exceptions: 'text/xml'
        });
        const fullUrl = `${apiUrl}?${params.toString()}`;

        if (!kakaoCadastralOverlayEl) {
          const overlay = document.createElement('div');
          overlay.id = 'kakaoCadastralOverlay';
          overlay.style.position = 'absolute';
          overlay.style.top = '0';
          overlay.style.left = '0';
          overlay.style.width = '100%';
          overlay.style.height = '100%';
          overlay.style.pointerEvents = 'none';
          overlay.style.zIndex = '6';
          const img = document.createElement('img');
          img.id = 'kakaoCadastralImage';
          img.style.width = '100%';
          img.style.height = '100%';
          img.style.imageRendering = 'pixelated';
          overlay.appendChild(img);
          const container = document.getElementById('kakaoMapContainer');
          container && container.appendChild(overlay);
          kakaoCadastralOverlayEl = overlay;

          // 지도 이동/확대 시 갱신
          kakao.maps.event.addListener(kakaoMap, 'idle', function() {
            if (cadastralOverlayMode === 'kakao') {
              setTimeout(() => updateCadastralOverlayKakao(), 300);
            }
          });
        }
        const imgEl = document.getElementById('kakaoCadastralImage');
        if (imgEl) imgEl.src = fullUrl;
        cadastralOverlayMode = 'kakao';
        updateCadastralButtonState(true);
      }
      function updateCadastralOverlayKakao() {
        if (!kakaoMap || !kakaoCadastralOverlayEl) return;
        const mapDiv = document.getElementById('kakaoMapDiv');
        if (!mapDiv) return;
        const bounds = kakaoMap.getBounds();
        if (!bounds) return;
        const sw = bounds.getSouthWest();
        const ne = bounds.getNorthEast();
        const bbox = `${sw.getLat()},${sw.getLng()},${ne.getLat()},${ne.getLng()}`;
        const width = mapDiv.offsetWidth;
        const height = mapDiv.offsetHeight;
        const apiUrl = 'https://api.vworld.kr/req/wms';
        const params = new URLSearchParams({
          key: '910896AA-BE88-363C-B54B-9FB421BD05DB',
          service: 'WMS',
          request: 'GetMap',
          version: '1.3.0',
          layers: 'lp_pa_cbnd_bonbun,lp_pa_cbnd_bubun',
          styles: '',
          crs: 'EPSG:4326',
          bbox: bbox,
          width: String(width),
          height: String(height),
          format: 'image/png',
          transparent: 'true',
          exceptions: 'text/xml'
        });
        const fullUrl = `${apiUrl}?${params.toString()}`;
        const imgEl = document.getElementById('kakaoCadastralImage');
        if (imgEl) imgEl.src = fullUrl;
      }
      function clearCadastralOverlayKakao() {
        if (kakaoCadastralOverlayEl) {
          kakaoCadastralOverlayEl.remove();
          kakaoCadastralOverlayEl = null;
        }
        if (cadastralOverlayMode === 'kakao') {
          cadastralOverlayMode = null;
        }
        updateCadastralButtonState(false);
      }
    </script>
    <!-- 구글 맵 API 스크립트. API 키와 콜백 함수(initMap) 지정 -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDVwJrvIcbqAOX24g9JODhD7DGtTz7z2Pg&callback=initMap" async defer></script>
</body>
</html>
